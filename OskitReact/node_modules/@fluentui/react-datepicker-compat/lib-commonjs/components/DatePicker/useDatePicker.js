"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useDatePicker_unstable", {
    enumerable: true,
    get: function() {
        return useDatePicker_unstable;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _keyboardkeys = require("@fluentui/keyboard-keys");
const _reactcalendarcompat = require("@fluentui/react-calendar-compat");
const _reacticons = require("@fluentui/react-icons");
const _defaults = require("./defaults");
const _reactinput = require("@fluentui/react-input");
const _reactutilities = require("@fluentui/react-utilities");
const _reactfield = require("@fluentui/react-field");
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _reacttabster = require("@fluentui/react-tabster");
const _usePopupPositioning = require("../../utils/usePopupPositioning");
function isDateOutOfBounds(date, minDate, maxDate) {
    return !!minDate && (0, _reactcalendarcompat.compareDatePart)(minDate, date) > 0 || !!maxDate && (0, _reactcalendarcompat.compareDatePart)(maxDate, date) < 0;
}
function useFocusLogic() {
    const inputRef = _react.useRef(null);
    const preventFocusOpeningPicker = _react.useRef(false);
    const focus = _react.useCallback(()=>{
        var _inputRef_current_focus, _inputRef_current;
        (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : (_inputRef_current_focus = _inputRef_current.focus) === null || _inputRef_current_focus === void 0 ? void 0 : _inputRef_current_focus.call(_inputRef_current);
    }, []);
    const preventNextFocusOpeningPicker = _react.useCallback(()=>{
        preventFocusOpeningPicker.current = true;
    }, []);
    return [
        focus,
        inputRef,
        preventFocusOpeningPicker,
        preventNextFocusOpeningPicker
    ];
}
function usePopupVisibility(props) {
    'use no memo';
    const [open, setOpen] = (0, _reactutilities.useControllableState)({
        initialState: false,
        defaultState: props.defaultOpen,
        state: props.open
    });
    const isMounted = _react.useRef(false);
    _react.useEffect(()=>{
        if (isMounted.current && !open) {
            var _props_onOpenChange;
            (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, false);
        }
        isMounted.current = true;
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        props.allowTextInput,
        open
    ]);
    return [
        open,
        setOpen
    ];
}
function useSelectedDate({ formatDate, onSelectDate, value }) {
    const [selectedDate, setSelectedDateState] = (0, _reactutilities.useControllableState)({
        initialState: null,
        state: value
    });
    const [formattedDate, setFormattedDate] = _react.useState(()=>value && formatDate ? formatDate(value) : '');
    const setSelectedDate = (newDate)=>{
        onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(newDate);
        setSelectedDateState(newDate);
        setFormattedDate(newDate && formatDate ? formatDate(newDate) : '');
    };
    _react.useEffect(()=>{
        setFormattedDate(value && formatDate ? formatDate(value) : '');
    }, [
        formatDate,
        value
    ]);
    return [
        selectedDate,
        formattedDate,
        setSelectedDate,
        setFormattedDate
    ];
}
const defaultFormatDate = (date)=>date ? date.toDateString() : '';
const defaultParseDateFromString = (dateStr)=>{
    const date = Date.parse(dateStr);
    return date ? new Date(date) : null;
};
const useDatePicker_unstable = (props, ref)=>{
    'use no memo';
    const { allowTextInput = false, allFocusable = false, borderless = false, dateTimeFormatter, defaultOpen = false, disableAutoFocus = true, firstDayOfWeek = _reactcalendarcompat.DayOfWeek.Sunday, firstWeekOfYear = _reactcalendarcompat.FirstWeekOfYear.FirstDay, formatDate = defaultFormatDate, highlightCurrentMonth = false, highlightSelectedMonth = false, initialPickerDate: initialPickerDateProp, inlinePopup = false, isMonthPickerVisible = true, maxDate, minDate, mountNode, onOpenChange, onSelectDate: onUserSelectDate, openOnClick = true, onValidationResult, parseDateFromString = defaultParseDateFromString, showCloseButton = false, showGoToToday = true, showMonthPickerAsOverlay = false, showWeekNumbers = false, strings = _defaults.defaultDatePickerStrings, today, underlined = false, value, ...restOfProps } = props;
    const initialPickerDate = _react.useMemo(()=>initialPickerDateProp !== null && initialPickerDateProp !== void 0 ? initialPickerDateProp : new Date(), [
        initialPickerDateProp
    ]);
    const calendar = _react.useRef(null);
    const [focus, rootRef, preventFocusOpeningPicker, preventNextFocusOpeningPicker] = useFocusLogic();
    const [selectedDate, formattedDate, setSelectedDate, setFormattedDate] = useSelectedDate({
        formatDate,
        onSelectDate: onUserSelectDate,
        value
    });
    const [open, setOpenState] = usePopupVisibility(props);
    const fieldContext = (0, _reactfield.useFieldContext_unstable)();
    var _fieldContext_required;
    const required = (_fieldContext_required = fieldContext === null || fieldContext === void 0 ? void 0 : fieldContext.required) !== null && _fieldContext_required !== void 0 ? _fieldContext_required : props.required;
    const defaultId = (0, _reactutilities.useId)('datePicker-input');
    const popupSurfaceId = (0, _reactutilities.useId)('datePicker-popupSurface');
    const validateTextInput = _react.useCallback((date = null)=>{
        let error;
        if (allowTextInput) {
            if (formattedDate || date) {
                // Don't parse if the selected date has the same formatted string as what we're about to parse.
                // The formatted string might be ambiguous (ex: "1/2/3" or "New Year Eve") and the parser might
                // not be able to come up with the exact same date.
                if (selectedDate && formatDate && formatDate(date !== null && date !== void 0 ? date : selectedDate) === formattedDate) {
                    return;
                }
                date = date || parseDateFromString(formattedDate);
                // Check if date is null or date is an invalid date
                if (!date || isNaN(date.getTime())) {
                    // Reset input if formatting is available
                    setSelectedDate(selectedDate);
                    error = 'invalid-input';
                } else {
                    if (isDateOutOfBounds(date, minDate, maxDate)) {
                        error = 'out-of-bounds';
                    } else {
                        setSelectedDate(date);
                    }
                }
            } else {
                if (required) {
                    error = 'required-input';
                }
                onUserSelectDate === null || onUserSelectDate === void 0 ? void 0 : onUserSelectDate(date);
            }
        } else if (required && !formattedDate) {
            error = 'required-input';
        }
        onValidationResult === null || onValidationResult === void 0 ? void 0 : onValidationResult({
            error
        });
    }, [
        allowTextInput,
        formatDate,
        formattedDate,
        maxDate,
        minDate,
        onUserSelectDate,
        onValidationResult,
        parseDateFromString,
        required,
        selectedDate,
        setSelectedDate
    ]);
    const setOpen = _react.useCallback((newState)=>{
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(newState);
        setOpenState(newState);
        if (!open && !props.disabled) {
            focus();
        }
    }, [
        focus,
        onOpenChange,
        props.disabled,
        setOpenState
    ]);
    const dismissDatePickerPopup = _react.useCallback((newlySelectedDate)=>{
        if (open) {
            setOpen(false);
            validateTextInput(newlySelectedDate);
            if (!allowTextInput && newlySelectedDate) {
                setSelectedDate(newlySelectedDate);
            }
        }
    }, [
        allowTextInput,
        open,
        setOpen,
        setSelectedDate,
        validateTextInput
    ]);
    const showDatePickerPopup = _react.useCallback(()=>{
        if (!open) {
            preventNextFocusOpeningPicker();
            setOpen(true);
        }
    }, [
        open,
        preventNextFocusOpeningPicker,
        setOpen
    ]);
    /**
   * Callback for closing the calendar callout
   */ const calendarDismissed = _react.useCallback((newlySelectedDate)=>{
        preventNextFocusOpeningPicker();
        dismissDatePickerPopup(newlySelectedDate);
    }, [
        dismissDatePickerPopup,
        preventNextFocusOpeningPicker
    ]);
    const onInputChange = _react.useCallback((ev, data)=>{
        const { value: newValue } = data;
        if (allowTextInput) {
            if (open) {
                dismissDatePickerPopup();
            }
            setFormattedDate(newValue);
        }
    }, [
        allowTextInput,
        dismissDatePickerPopup,
        open,
        setFormattedDate
    ]);
    const onInputBlur = _react.useCallback(()=>{
        validateTextInput();
    }, [
        validateTextInput
    ]);
    const onInputKeyDown = _react.useCallback((ev)=>{
        switch(ev.key){
            case _keyboardkeys.Enter:
                ev.preventDefault();
                ev.stopPropagation();
                if (!open) {
                    validateTextInput();
                    showDatePickerPopup();
                } else {
                    // When DatePicker allows input date string directly,
                    // it is expected to hit another enter to close the popup
                    if (props.allowTextInput) {
                        dismissDatePickerPopup();
                    }
                }
                break;
            case _keyboardkeys.Escape:
                ev.stopPropagation();
                ev.preventDefault();
                if (open) {
                    calendarDismissed();
                }
                break;
            case _keyboardkeys.ArrowDown:
                ev.preventDefault();
                if (!open) {
                    showDatePickerPopup();
                }
                break;
            default:
                break;
        }
    }, [
        calendarDismissed,
        dismissDatePickerPopup,
        open,
        props.allowTextInput,
        showDatePickerPopup,
        validateTextInput
    ]);
    const onInputFocus = _react.useCallback(()=>{
        if (disableAutoFocus) {
            return;
        }
        if (!allowTextInput) {
            if (!preventFocusOpeningPicker.current) {
                showDatePickerPopup();
            }
            preventFocusOpeningPicker.current = false;
        }
    }, [
        allowTextInput,
        disableAutoFocus,
        preventFocusOpeningPicker,
        showDatePickerPopup
    ]);
    const onInputClick = _react.useCallback(()=>{
        // default openOnClick to !props.disableAutoFocus for legacy support of disableAutoFocus behavior
        if ((props.openOnClick || !props.disableAutoFocus) && !open && !props.disabled) {
            showDatePickerPopup();
            return;
        }
        if (allowTextInput) {
            dismissDatePickerPopup();
        }
    }, [
        allowTextInput,
        dismissDatePickerPopup,
        open,
        props.disabled,
        props.disableAutoFocus,
        props.openOnClick,
        showDatePickerPopup
    ]);
    const onIconClick = (ev)=>{
        ev.stopPropagation();
        if (!open && !props.disabled) {
            showDatePickerPopup();
        } else if (props.allowTextInput) {
            dismissDatePickerPopup();
        }
    };
    const inputAppearance = underlined ? 'underline' : borderless ? 'filled-lighter' : 'outline';
    const [triggerWrapperRef, popupRef] = (0, _usePopupPositioning.usePopupPositioning)(props);
    const inputRoot = _reactutilities.slot.always(props.root, {
        defaultProps: {
            ref: triggerWrapperRef
        },
        elementType: 'span'
    });
    inputRoot.ref = (0, _reactutilities.useMergedRefs)(inputRoot.ref, triggerWrapperRef);
    const input = _reactutilities.slot.always(props.input, {
        elementType: 'input'
    });
    input.ref = (0, _reactutilities.useMergedRefs)(input.ref, ref, rootRef);
    // Props to create a semantic but non-focusable button on the element with the click-to-open handler
    // Used for voice control and touch screen reader accessibility
    const inputLabelledBy = props['aria-labelledby'];
    var _props_id;
    const inputId = (_props_id = props.id) !== null && _props_id !== void 0 ? _props_id : defaultId;
    const iconA11yProps = _react.useMemo(()=>({
            role: 'button',
            'aria-expanded': open,
            'aria-labelledby': inputLabelledBy !== null && inputLabelledBy !== void 0 ? inputLabelledBy : inputId
        }), [
        open,
        inputLabelledBy,
        inputId
    ]);
    const contentAfter = _reactutilities.slot.always(props.contentAfter || {}, {
        defaultProps: {
            children: /*#__PURE__*/ _react.createElement(_reacticons.CalendarMonthRegular, null),
            ...iconA11yProps
        },
        elementType: 'span'
    });
    contentAfter.onClick = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(contentAfter.onClick, onIconClick));
    const root = _reactutilities.slot.always(restOfProps, {
        defaultProps: {
            appearance: inputAppearance,
            'aria-controls': open ? popupSurfaceId : undefined,
            'aria-expanded': open,
            'aria-haspopup': 'dialog',
            readOnly: !allowTextInput,
            role: 'combobox',
            id: inputId
        },
        elementType: _reactinput.Input
    });
    root.root = inputRoot;
    root.input = input;
    root.contentAfter = contentAfter;
    root.onChange = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(root.onChange, onInputChange));
    root.onBlur = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(root.onBlur, onInputBlur));
    root.onKeyDown = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(root.onKeyDown, onInputKeyDown));
    root.onFocus = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(root.onFocus, onInputFocus));
    root.onClick = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(root.onClick, onInputClick));
    const { modalAttributes } = (0, _reacttabster.useModalAttributes)({
        trapFocus: true,
        alwaysFocusable: true,
        legacyTrapFocus: true
    });
    const popupSurface = open ? _reactutilities.slot.optional(props.popupSurface, {
        renderByDefault: true,
        defaultProps: {
            'aria-label': 'Calendar',
            'aria-modal': true,
            id: popupSurfaceId,
            role: 'dialog',
            ref: popupRef,
            ...modalAttributes
        },
        elementType: 'div'
    }) : undefined;
    const { targetDocument } = (0, _reactsharedcontexts.useFluent_unstable)();
    (0, _reactutilities.useOnClickOutside)({
        element: targetDocument,
        callback: (ev)=>dismissDatePickerPopup(),
        refs: [
            triggerWrapperRef,
            popupRef
        ],
        disabled: !open
    });
    (0, _reactutilities.useOnScrollOutside)({
        element: targetDocument,
        callback: (ev)=>dismissDatePickerPopup(),
        refs: [
            triggerWrapperRef,
            popupRef
        ],
        disabled: !open
    }); // When the popup is opened, focus should go to the calendar.
    // In v8 this was done by focusing after the callout was positioned, but in v9 this can be simulated by using a
    // useEffect hook.
    _react.useEffect(()=>{
        if (open && !props.disabled && calendar.current) {
            calendar.current.focus();
        }
    }, [
        disableAutoFocus,
        open,
        props.disabled
    ]);
    const calendarShorthand = _reactutilities.slot.always(props.calendar, {
        defaultProps: {
            allFocusable,
            componentRef: calendar,
            dateTimeFormatter,
            firstDayOfWeek,
            firstWeekOfYear,
            highlightCurrentMonth,
            highlightSelectedMonth,
            isMonthPickerVisible,
            maxDate,
            minDate,
            showCloseButton,
            showGoToToday,
            showMonthPickerAsOverlay,
            showWeekNumbers,
            strings,
            today,
            value: selectedDate || initialPickerDate
        },
        elementType: _reactcalendarcompat.Calendar
    });
    calendarShorthand.onDismiss = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(calendarShorthand.onDismiss, calendarDismissed));
    calendarShorthand.onSelectDate = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(calendarShorthand.onSelectDate, calendarDismissed));
    const state = {
        disabled: !!props.disabled,
        inlinePopup,
        components: {
            root: _reactinput.Input,
            calendar: _reactcalendarcompat.Calendar,
            popupSurface: 'div'
        },
        calendar: calendarShorthand,
        mountNode,
        root,
        popupSurface
    };
    state.root.value = formattedDate;
    return state;
};
