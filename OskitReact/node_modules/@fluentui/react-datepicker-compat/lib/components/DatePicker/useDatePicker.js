import * as React from 'react';
import { ArrowDown, Enter, Escape } from '@fluentui/keyboard-keys';
import { Calendar, compareDatePart, DayOfWeek, FirstWeekOfYear } from '@fluentui/react-calendar-compat';
import { CalendarMonthRegular } from '@fluentui/react-icons';
import { defaultDatePickerStrings } from './defaults';
import { Input } from '@fluentui/react-input';
import { mergeCallbacks, useControllableState, useEventCallback, useId, useMergedRefs, useOnClickOutside, useOnScrollOutside, slot } from '@fluentui/react-utilities';
import { useFieldContext_unstable as useFieldContext } from '@fluentui/react-field';
import { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { useModalAttributes } from '@fluentui/react-tabster';
import { usePopupPositioning } from '../../utils/usePopupPositioning';
function isDateOutOfBounds(date, minDate, maxDate) {
    return !!minDate && compareDatePart(minDate, date) > 0 || !!maxDate && compareDatePart(maxDate, date) < 0;
}
function useFocusLogic() {
    const inputRef = React.useRef(null);
    const preventFocusOpeningPicker = React.useRef(false);
    const focus = React.useCallback(()=>{
        var _inputRef_current_focus, _inputRef_current;
        (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : (_inputRef_current_focus = _inputRef_current.focus) === null || _inputRef_current_focus === void 0 ? void 0 : _inputRef_current_focus.call(_inputRef_current);
    }, []);
    const preventNextFocusOpeningPicker = React.useCallback(()=>{
        preventFocusOpeningPicker.current = true;
    }, []);
    return [
        focus,
        inputRef,
        preventFocusOpeningPicker,
        preventNextFocusOpeningPicker
    ];
}
function usePopupVisibility(props) {
    'use no memo';
    const [open, setOpen] = useControllableState({
        initialState: false,
        defaultState: props.defaultOpen,
        state: props.open
    });
    const isMounted = React.useRef(false);
    React.useEffect(()=>{
        if (isMounted.current && !open) {
            var // If DatePicker's menu (Calendar) is closed, run onAfterMenuDismiss
            _props_onOpenChange;
            (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, false);
        }
        isMounted.current = true;
    }, // Should only run on allowTextInput or open change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        props.allowTextInput,
        open
    ]);
    return [
        open,
        setOpen
    ];
}
function useSelectedDate({ formatDate, onSelectDate, value }) {
    const [selectedDate, setSelectedDateState] = useControllableState({
        initialState: null,
        state: value
    });
    const [formattedDate, setFormattedDate] = React.useState(()=>value && formatDate ? formatDate(value) : '');
    const setSelectedDate = (newDate)=>{
        onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(newDate);
        setSelectedDateState(newDate);
        setFormattedDate(newDate && formatDate ? formatDate(newDate) : '');
    };
    React.useEffect(()=>{
        setFormattedDate(value && formatDate ? formatDate(value) : '');
    }, [
        formatDate,
        value
    ]);
    return [
        selectedDate,
        formattedDate,
        setSelectedDate,
        setFormattedDate
    ];
}
const defaultFormatDate = (date)=>date ? date.toDateString() : '';
const defaultParseDateFromString = (dateStr)=>{
    const date = Date.parse(dateStr);
    return date ? new Date(date) : null;
};
/**
 * Create the state required to render DatePicker.
 *
 * The returned state can be modified with hooks such as useDatePickerStyles_unstable,
 * before being passed to renderDatePicker_unstable.
 *
 * @param props - props from this instance of DatePicker
 * @param ref - reference to root Input slot
 */ export const useDatePicker_unstable = (props, ref)=>{
    'use no memo';
    const { allowTextInput = false, allFocusable = false, borderless = false, dateTimeFormatter, defaultOpen = false, disableAutoFocus = true, firstDayOfWeek = DayOfWeek.Sunday, firstWeekOfYear = FirstWeekOfYear.FirstDay, formatDate = defaultFormatDate, highlightCurrentMonth = false, highlightSelectedMonth = false, initialPickerDate: initialPickerDateProp, inlinePopup = false, isMonthPickerVisible = true, maxDate, minDate, mountNode, onOpenChange, onSelectDate: onUserSelectDate, openOnClick = true, onValidationResult, parseDateFromString = defaultParseDateFromString, showCloseButton = false, showGoToToday = true, showMonthPickerAsOverlay = false, showWeekNumbers = false, strings = defaultDatePickerStrings, today, underlined = false, value, ...restOfProps } = props;
    const initialPickerDate = React.useMemo(()=>initialPickerDateProp !== null && initialPickerDateProp !== void 0 ? initialPickerDateProp : new Date(), [
        initialPickerDateProp
    ]);
    const calendar = React.useRef(null);
    const [focus, rootRef, preventFocusOpeningPicker, preventNextFocusOpeningPicker] = useFocusLogic();
    const [selectedDate, formattedDate, setSelectedDate, setFormattedDate] = useSelectedDate({
        formatDate,
        onSelectDate: onUserSelectDate,
        value
    });
    const [open, setOpenState] = usePopupVisibility(props);
    const fieldContext = useFieldContext();
    var _fieldContext_required;
    const required = (_fieldContext_required = fieldContext === null || fieldContext === void 0 ? void 0 : fieldContext.required) !== null && _fieldContext_required !== void 0 ? _fieldContext_required : props.required;
    const defaultId = useId('datePicker-input');
    const popupSurfaceId = useId('datePicker-popupSurface');
    const validateTextInput = React.useCallback((date = null)=>{
        let error;
        if (allowTextInput) {
            if (formattedDate || date) {
                // Don't parse if the selected date has the same formatted string as what we're about to parse.
                // The formatted string might be ambiguous (ex: "1/2/3" or "New Year Eve") and the parser might
                // not be able to come up with the exact same date.
                if (selectedDate && formatDate && formatDate(date !== null && date !== void 0 ? date : selectedDate) === formattedDate) {
                    return;
                }
                date = date || parseDateFromString(formattedDate);
                // Check if date is null or date is an invalid date
                if (!date || isNaN(date.getTime())) {
                    // Reset input if formatting is available
                    setSelectedDate(selectedDate);
                    error = 'invalid-input';
                } else {
                    if (isDateOutOfBounds(date, minDate, maxDate)) {
                        error = 'out-of-bounds';
                    } else {
                        setSelectedDate(date);
                    }
                }
            } else {
                if (required) {
                    error = 'required-input';
                }
                onUserSelectDate === null || onUserSelectDate === void 0 ? void 0 : onUserSelectDate(date);
            }
        } else if (required && !formattedDate) {
            error = 'required-input';
        }
        onValidationResult === null || onValidationResult === void 0 ? void 0 : onValidationResult({
            error
        });
    }, [
        allowTextInput,
        formatDate,
        formattedDate,
        maxDate,
        minDate,
        onUserSelectDate,
        onValidationResult,
        parseDateFromString,
        required,
        selectedDate,
        setSelectedDate
    ]);
    const setOpen = React.useCallback((newState)=>{
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(newState);
        setOpenState(newState);
        if (!open && !props.disabled) {
            focus();
        }
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        focus,
        onOpenChange,
        props.disabled,
        setOpenState
    ]);
    const dismissDatePickerPopup = React.useCallback((newlySelectedDate)=>{
        if (open) {
            setOpen(false);
            validateTextInput(newlySelectedDate);
            if (!allowTextInput && newlySelectedDate) {
                setSelectedDate(newlySelectedDate);
            }
        }
    }, [
        allowTextInput,
        open,
        setOpen,
        setSelectedDate,
        validateTextInput
    ]);
    const showDatePickerPopup = React.useCallback(()=>{
        if (!open) {
            preventNextFocusOpeningPicker();
            setOpen(true);
        }
    }, [
        open,
        preventNextFocusOpeningPicker,
        setOpen
    ]);
    /**
   * Callback for closing the calendar callout
   */ const calendarDismissed = React.useCallback((newlySelectedDate)=>{
        preventNextFocusOpeningPicker();
        dismissDatePickerPopup(newlySelectedDate);
    }, [
        dismissDatePickerPopup,
        preventNextFocusOpeningPicker
    ]);
    const onInputChange = React.useCallback((ev, data)=>{
        const { value: newValue } = data;
        if (allowTextInput) {
            if (open) {
                dismissDatePickerPopup();
            }
            setFormattedDate(newValue);
        }
    }, [
        allowTextInput,
        dismissDatePickerPopup,
        open,
        setFormattedDate
    ]);
    const onInputBlur = React.useCallback(()=>{
        validateTextInput();
    }, [
        validateTextInput
    ]);
    const onInputKeyDown = React.useCallback((ev)=>{
        switch(ev.key){
            case Enter:
                ev.preventDefault();
                ev.stopPropagation();
                if (!open) {
                    validateTextInput();
                    showDatePickerPopup();
                } else {
                    // When DatePicker allows input date string directly,
                    // it is expected to hit another enter to close the popup
                    if (props.allowTextInput) {
                        dismissDatePickerPopup();
                    }
                }
                break;
            case Escape:
                ev.stopPropagation();
                ev.preventDefault();
                if (open) {
                    calendarDismissed();
                }
                break;
            case ArrowDown:
                ev.preventDefault();
                if (!open) {
                    showDatePickerPopup();
                }
                break;
            default:
                break;
        }
    }, [
        calendarDismissed,
        dismissDatePickerPopup,
        open,
        props.allowTextInput,
        showDatePickerPopup,
        validateTextInput
    ]);
    const onInputFocus = React.useCallback(()=>{
        if (disableAutoFocus) {
            return;
        }
        if (!allowTextInput) {
            if (!preventFocusOpeningPicker.current) {
                showDatePickerPopup();
            }
            preventFocusOpeningPicker.current = false;
        }
    }, [
        allowTextInput,
        disableAutoFocus,
        preventFocusOpeningPicker,
        showDatePickerPopup
    ]);
    const onInputClick = React.useCallback(()=>{
        // default openOnClick to !props.disableAutoFocus for legacy support of disableAutoFocus behavior
        if ((props.openOnClick || !props.disableAutoFocus) && !open && !props.disabled) {
            showDatePickerPopup();
            return;
        }
        if (allowTextInput) {
            dismissDatePickerPopup();
        }
    }, [
        allowTextInput,
        dismissDatePickerPopup,
        open,
        props.disabled,
        props.disableAutoFocus,
        props.openOnClick,
        showDatePickerPopup
    ]);
    const onIconClick = (ev)=>{
        ev.stopPropagation();
        if (!open && !props.disabled) {
            showDatePickerPopup();
        } else if (props.allowTextInput) {
            dismissDatePickerPopup();
        }
    };
    const inputAppearance = underlined ? 'underline' : borderless ? 'filled-lighter' : 'outline';
    const [triggerWrapperRef, popupRef] = usePopupPositioning(props);
    const inputRoot = slot.always(props.root, {
        defaultProps: {
            ref: triggerWrapperRef
        },
        elementType: 'span'
    });
    inputRoot.ref = useMergedRefs(inputRoot.ref, triggerWrapperRef);
    const input = slot.always(props.input, {
        elementType: 'input'
    });
    input.ref = useMergedRefs(input.ref, ref, rootRef);
    // Props to create a semantic but non-focusable button on the element with the click-to-open handler
    // Used for voice control and touch screen reader accessibility
    const inputLabelledBy = props['aria-labelledby'];
    var _props_id;
    const inputId = (_props_id = props.id) !== null && _props_id !== void 0 ? _props_id : defaultId;
    const iconA11yProps = React.useMemo(()=>({
            role: 'button',
            'aria-expanded': open,
            'aria-labelledby': inputLabelledBy !== null && inputLabelledBy !== void 0 ? inputLabelledBy : inputId
        }), [
        open,
        inputLabelledBy,
        inputId
    ]);
    const contentAfter = slot.always(props.contentAfter || {}, {
        defaultProps: {
            children: /*#__PURE__*/ React.createElement(CalendarMonthRegular, null),
            ...iconA11yProps
        },
        elementType: 'span'
    });
    contentAfter.onClick = useEventCallback(mergeCallbacks(contentAfter.onClick, onIconClick));
    const root = slot.always(restOfProps, {
        defaultProps: {
            appearance: inputAppearance,
            'aria-controls': open ? popupSurfaceId : undefined,
            'aria-expanded': open,
            'aria-haspopup': 'dialog',
            readOnly: !allowTextInput,
            role: 'combobox',
            id: inputId
        },
        elementType: Input
    });
    root.root = inputRoot;
    root.input = input;
    root.contentAfter = contentAfter;
    root.onChange = useEventCallback(mergeCallbacks(root.onChange, onInputChange));
    root.onBlur = useEventCallback(mergeCallbacks(root.onBlur, onInputBlur));
    root.onKeyDown = useEventCallback(mergeCallbacks(root.onKeyDown, onInputKeyDown));
    root.onFocus = useEventCallback(mergeCallbacks(root.onFocus, onInputFocus));
    root.onClick = useEventCallback(mergeCallbacks(root.onClick, onInputClick));
    const { modalAttributes } = useModalAttributes({
        trapFocus: true,
        alwaysFocusable: true,
        legacyTrapFocus: true
    });
    const popupSurface = open ? slot.optional(props.popupSurface, {
        renderByDefault: true,
        defaultProps: {
            'aria-label': 'Calendar',
            'aria-modal': true,
            id: popupSurfaceId,
            role: 'dialog',
            ref: popupRef,
            ...modalAttributes
        },
        elementType: 'div'
    }) : undefined;
    const { targetDocument } = useFluent();
    useOnClickOutside({
        element: targetDocument,
        callback: (ev)=>dismissDatePickerPopup(),
        refs: [
            triggerWrapperRef,
            popupRef
        ],
        disabled: !open
    });
    useOnScrollOutside({
        element: targetDocument,
        callback: (ev)=>dismissDatePickerPopup(),
        refs: [
            triggerWrapperRef,
            popupRef
        ],
        disabled: !open
    }); // When the popup is opened, focus should go to the calendar.
    // In v8 this was done by focusing after the callout was positioned, but in v9 this can be simulated by using a
    // useEffect hook.
    React.useEffect(()=>{
        if (open && !props.disabled && calendar.current) {
            calendar.current.focus();
        }
    }, [
        disableAutoFocus,
        open,
        props.disabled
    ]);
    const calendarShorthand = slot.always(props.calendar, {
        defaultProps: {
            allFocusable,
            componentRef: calendar,
            dateTimeFormatter,
            firstDayOfWeek,
            firstWeekOfYear,
            highlightCurrentMonth,
            highlightSelectedMonth,
            isMonthPickerVisible,
            maxDate,
            minDate,
            showCloseButton,
            showGoToToday,
            showMonthPickerAsOverlay,
            showWeekNumbers,
            strings,
            today,
            value: selectedDate || initialPickerDate
        },
        elementType: Calendar
    });
    calendarShorthand.onDismiss = useEventCallback(mergeCallbacks(calendarShorthand.onDismiss, calendarDismissed));
    calendarShorthand.onSelectDate = useEventCallback(mergeCallbacks(calendarShorthand.onSelectDate, calendarDismissed));
    const state = {
        disabled: !!props.disabled,
        inlinePopup,
        components: {
            root: Input,
            calendar: Calendar,
            popupSurface: 'div'
        },
        calendar: calendarShorthand,
        mountNode,
        root,
        popupSurface
    };
    state.root.value = formattedDate;
    return state;
};
