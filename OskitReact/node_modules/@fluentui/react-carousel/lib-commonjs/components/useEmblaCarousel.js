"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    EMBLA_VISIBILITY_EVENT: function() {
        return EMBLA_VISIBILITY_EVENT;
    },
    setTabsterDefault: function() {
        return setTabsterDefault;
    },
    useEmblaCarousel: function() {
        return useEmblaCarousel;
    }
});
const _interop_require_default = require("@swc/helpers/_/_interop_require_default");
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _reactutilities = require("@fluentui/react-utilities");
const _emblacarousel = /*#__PURE__*/ _interop_require_default._(require("embla-carousel"));
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _useCarouselCardStylesstyles = require("./CarouselCard/useCarouselCardStyles.styles");
const _useCarouselSliderStylesstyles = require("./CarouselSlider/useCarouselSliderStyles.styles");
const _emblacarouselautoplay = /*#__PURE__*/ _interop_require_default._(require("embla-carousel-autoplay"));
const _emblacarouselfade = /*#__PURE__*/ _interop_require_default._(require("embla-carousel-fade"));
const sliderClassname = `.${_useCarouselSliderStylesstyles.carouselSliderClassNames.root}`;
const DEFAULT_EMBLA_OPTIONS = {
    containScroll: 'trimSnaps',
    inViewThreshold: 0.99,
    watchDrag: false,
    skipSnaps: true,
    container: sliderClassname,
    slides: `.${_useCarouselCardStylesstyles.carouselCardClassNames.root}`
};
const EMBLA_VISIBILITY_EVENT = 'embla:visibilitychange';
function setTabsterDefault(element, isDefault) {
    const tabsterAttr = element.getAttribute('data-tabster');
    if (tabsterAttr) {
        const tabsterAttributes = JSON.parse(tabsterAttr);
        if (tabsterAttributes.focusable) {
            // If tabster.focusable isn't present, we will ignore.
            tabsterAttributes.focusable.isDefault = isDefault;
            element.setAttribute('data-tabster', JSON.stringify(tabsterAttributes));
        }
    }
}
function useEmblaCarousel(options) {
    const { align, direction, loop, slidesToScroll, watchDrag, containScroll, motion } = options;
    const [activeIndex, setActiveIndex] = (0, _reactutilities.useControllableState)({
        defaultState: options.defaultActiveIndex,
        state: options.activeIndex,
        initialState: 0
    });
    const emblaOptions = _react.useRef({
        align,
        direction,
        loop,
        slidesToScroll,
        startIndex: activeIndex,
        watchDrag,
        containScroll
    });
    const emblaApi = _react.useRef(null);
    const autoplayRef = _react.useRef(false);
    const resetAutoplay = _react.useCallback(()=>{
        var _emblaApi_current;
        (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.plugins().autoplay.reset();
    }, []);
    /* Our autoplay button, which is required by standards for autoplay to be enabled, will handle controlled state */ const enableAutoplay = _react.useCallback((autoplay)=>{
        autoplayRef.current = autoplay;
        if (autoplay) {
            var _emblaApi_current;
            (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.plugins().autoplay.play();
            // Reset after play to ensure timing and any focus/mouse pause state is reset.
            resetAutoplay();
        } else {
            var _emblaApi_current1;
            (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.plugins().autoplay.stop();
        }
    }, [
        resetAutoplay
    ]);
    const getPlugins = _react.useCallback(()=>{
        const plugins = [
            (0, _emblacarouselautoplay.default)({
                playOnInit: autoplayRef.current,
                stopOnInteraction: !autoplayRef.current,
                stopOnMouseEnter: true,
                stopOnFocusIn: true,
                rootNode: (emblaRoot)=>{
                    var _emblaRoot_querySelector;
                    return (_emblaRoot_querySelector = emblaRoot.querySelector(sliderClassname)) !== null && _emblaRoot_querySelector !== void 0 ? _emblaRoot_querySelector : emblaRoot;
                }
            })
        ];
        // Optionally add Fade plugin
        if (motion === 'fade') {
            plugins.push((0, _emblacarouselfade.default)());
        }
        return plugins;
    }, [
        motion
    ]);
    // Listeners contains callbacks for UI elements that may require state update based on embla changes
    const listeners = _react.useRef(new Set());
    const subscribeForValues = _react.useCallback((listener)=>{
        listeners.current.add(listener);
        return ()=>{
            listeners.current.delete(listener);
        };
    }, []);
    const containerRef = _react.useMemo(()=>{
        let currentElement = null;
        const handleIndexChange = ()=>{
            var _emblaApi_current, _emblaApi_current1, _emblaApi_current2;
            var _emblaApi_current_selectedScrollSnap;
            const newIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
            const slides = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slideNodes();
            var _emblaApi_current_internalEngine_slideRegistry_newIndex_;
            const actualIndex = (_emblaApi_current_internalEngine_slideRegistry_newIndex_ = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.internalEngine().slideRegistry[newIndex][0]) !== null && _emblaApi_current_internalEngine_slideRegistry_newIndex_ !== void 0 ? _emblaApi_current_internalEngine_slideRegistry_newIndex_ : 0;
            // We set the active or first index of group on-screen as the selected tabster index
            slides === null || slides === void 0 ? void 0 : slides.forEach((slide, slideIndex)=>{
                setTabsterDefault(slide, slideIndex === actualIndex);
            });
            setActiveIndex(newIndex);
        };
        const handleReinit = ()=>{
            var _emblaApi_current, _emblaApi_current1, _emblaApi_current2;
            var _emblaApi_current_slideNodes;
            const nodes = (_emblaApi_current_slideNodes = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes()) !== null && _emblaApi_current_slideNodes !== void 0 ? _emblaApi_current_slideNodes : [];
            var _emblaApi_current_internalEngine_slideRegistry;
            const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
            const navItemsCount = groupIndexList.length > 0 ? groupIndexList.length : nodes.length;
            var _emblaApi_current_selectedScrollSnap;
            const data = {
                navItemsCount,
                activeIndex: (_emblaApi_current_selectedScrollSnap = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0,
                groupIndexList,
                slideNodes: nodes
            };
            for (const listener of listeners.current){
                listener(data);
            }
        };
        const handleVisibilityChange = ()=>{
            var _emblaApi_current, _emblaApi_current1;
            const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
            var _emblaApi_current_slidesInView;
            const visibleIndexes = (_emblaApi_current_slidesInView = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slidesInView()) !== null && _emblaApi_current_slidesInView !== void 0 ? _emblaApi_current_slidesInView : [];
            cardElements === null || cardElements === void 0 ? void 0 : cardElements.forEach((cardElement, index)=>{
                cardElement.dispatchEvent(new CustomEvent(EMBLA_VISIBILITY_EVENT, {
                    bubbles: false,
                    detail: {
                        isVisible: visibleIndexes.includes(index)
                    }
                }));
            });
        };
        const plugins = getPlugins();
        return {
            set current (newElement){
                if (currentElement) {
                    var _emblaApi_current, _emblaApi_current1, _emblaApi_current2, _emblaApi_current3;
                    (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.off('slidesInView', handleVisibilityChange);
                    (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.off('select', handleIndexChange);
                    (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.off('reInit', handleReinit);
                    (_emblaApi_current3 = emblaApi.current) === null || _emblaApi_current3 === void 0 ? void 0 : _emblaApi_current3.destroy();
                }
                if (newElement) {
                    var _emblaApi_current4, _emblaApi_current5, _emblaApi_current6;
                    currentElement = newElement;
                    emblaApi.current = (0, _emblacarousel.default)(newElement, {
                        ...DEFAULT_EMBLA_OPTIONS,
                        ...emblaOptions.current
                    }, plugins);
                    (_emblaApi_current4 = emblaApi.current) === null || _emblaApi_current4 === void 0 ? void 0 : _emblaApi_current4.on('reInit', handleReinit);
                    (_emblaApi_current5 = emblaApi.current) === null || _emblaApi_current5 === void 0 ? void 0 : _emblaApi_current5.on('slidesInView', handleVisibilityChange);
                    (_emblaApi_current6 = emblaApi.current) === null || _emblaApi_current6 === void 0 ? void 0 : _emblaApi_current6.on('select', handleIndexChange);
                }
            }
        };
    }, [
        getPlugins,
        setActiveIndex
    ]);
    const carouselApi = _react.useMemo(()=>({
            scrollToElement: (element, jump)=>{
                var _emblaApi_current, _emblaApi_current1, _emblaApi_current2;
                const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
                var _emblaApi_current_internalEngine_slideRegistry;
                const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
                var _cardElements_indexOf;
                const cardIndex = (_cardElements_indexOf = cardElements === null || cardElements === void 0 ? void 0 : cardElements.indexOf(element)) !== null && _cardElements_indexOf !== void 0 ? _cardElements_indexOf : 0;
                const groupIndex = groupIndexList.findIndex((group)=>{
                    return group.includes(cardIndex);
                });
                const indexFocus = groupIndex !== null && groupIndex !== void 0 ? groupIndex : cardIndex;
                (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollTo(indexFocus, jump);
                return indexFocus;
            },
            scrollToIndex: (index, jump)=>{
                var _emblaApi_current;
                (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.scrollTo(index, jump);
            },
            scrollInDirection: (dir)=>{
                var _emblaApi_current;
                if (dir === 'prev') {
                    var _emblaApi_current1;
                    (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.scrollPrev();
                } else {
                    var _emblaApi_current2;
                    (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollNext();
                }
                var _emblaApi_current_selectedScrollSnap;
                return (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
            }
        }), []);
    _react.useEffect(()=>{
        var _emblaApi_current;
        var _emblaApi_current_selectedScrollSnap;
        const currentActiveIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
        if (activeIndex !== currentActiveIndex) {
            var _emblaApi_current1;
            (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.scrollTo(activeIndex);
        }
    }, [
        activeIndex
    ]);
    _react.useEffect(()=>{
        var _emblaApi_current;
        const plugins = getPlugins();
        emblaOptions.current = {
            align,
            direction,
            loop,
            slidesToScroll,
            watchDrag,
            containScroll
        };
        (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.reInit({
            ...DEFAULT_EMBLA_OPTIONS,
            ...emblaOptions.current
        }, plugins);
    }, [
        align,
        direction,
        loop,
        slidesToScroll,
        watchDrag,
        containScroll,
        getPlugins
    ]);
    return {
        activeIndex,
        carouselApi,
        containerRef,
        subscribeForValues,
        enableAutoplay,
        resetAutoplay
    };
}
