"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Calendar", {
    enumerable: true,
    get: function() {
        return Calendar;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _keyboardkeys = require("@fluentui/keyboard-keys");
const _reactutilities = require("@fluentui/react-utilities");
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _utils = require("../../utils");
const _CalendarDay = require("../CalendarDay/CalendarDay");
const _CalendarMonth = require("../CalendarMonth/CalendarMonth");
const _calendarNavigationIcons = require("./calendarNavigationIcons");
const _useCalendarStylesstyles = require("./useCalendarStyles.styles");
const MIN_SIZE_FORCE_OVERLAY = 440;
const defaultWorkWeekDays = [
    _utils.DayOfWeek.Monday,
    _utils.DayOfWeek.Tuesday,
    _utils.DayOfWeek.Wednesday,
    _utils.DayOfWeek.Thursday,
    _utils.DayOfWeek.Friday
];
function useDateState(props) {
    const { value, today: todayProp, onSelectDate } = props;
    const today = _react.useMemo(()=>todayProp !== null && todayProp !== void 0 ? todayProp : new Date(), [
        todayProp
    ]);
    /** The currently selected date in the calendar */ const [selectedDate, setSelectedDate] = (0, _reactutilities.useControllableState)({
        state: value,
        defaultState: value ? undefined : today,
        initialState: today
    });
    /** The currently focused date in the day picker, but not necessarily selected */ const [navigatedDay = today, setNavigatedDay] = _react.useState(value);
    /** The currently focused date in the month picker, but not necessarily selected */ const [navigatedMonth = today, setNavigatedMonth] = _react.useState(value);
    /** If using a controlled value, when that value changes, navigate to that date */ const [lastSelectedDate = today, setLastSelectedDate] = _react.useState(value);
    if (value && lastSelectedDate.valueOf() !== value.valueOf()) {
        setNavigatedDay(value);
        setNavigatedMonth(value);
        setLastSelectedDate(value);
    }
    const navigateMonth = (date)=>{
        setNavigatedMonth(date);
    };
    const navigateDay = (date)=>{
        setNavigatedMonth(date);
        setNavigatedDay(date);
    };
    const onDateSelected = (date, selectedDateRangeArray)=>{
        setNavigatedMonth(date);
        setNavigatedDay(date);
        setSelectedDate(date);
        onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(date, selectedDateRangeArray);
    };
    return [
        selectedDate,
        navigatedDay,
        navigatedMonth,
        onDateSelected,
        navigateDay,
        navigateMonth
    ];
}
function useVisibilityState({ isDayPickerVisible: isDayPickerVisibleProp, isMonthPickerVisible: isMonthPickerVisibleProp, showMonthPickerAsOverlay }) {
    /** State used to show/hide month picker */ const showMonthPickerAsOverlayState = useShowMonthPickerAsOverlay({
        isDayPickerVisible: isDayPickerVisibleProp,
        showMonthPickerAsOverlay
    });
    const [isMonthPickerVisible, setIsMonthPickerVisible] = _react.useState(()=>showMonthPickerAsOverlayState ? false : isMonthPickerVisibleProp !== null && isMonthPickerVisibleProp !== void 0 ? isMonthPickerVisibleProp : false);
    /** State used to show/hide day picker */ const [isDayPickerVisible, setIsDayPickerVisible] = _react.useState(()=>showMonthPickerAsOverlayState ? true : isDayPickerVisibleProp !== null && isDayPickerVisibleProp !== void 0 ? isDayPickerVisibleProp : true);
    const toggleDayMonthPickerVisibility = ()=>{
        setIsMonthPickerVisible(!isMonthPickerVisible);
        setIsDayPickerVisible(!isDayPickerVisible);
    };
    return [
        isMonthPickerVisible,
        isDayPickerVisible,
        toggleDayMonthPickerVisibility
    ];
}
function useFocusLogic({ componentRef }, isDayPickerVisible, isMonthPickerVisible) {
    const dayPicker = _react.useRef(null);
    const monthPicker = _react.useRef(null);
    const focusOnUpdate = _react.useRef(false);
    const { targetDocument } = (0, _reactsharedcontexts.useFluent_unstable)();
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    const focus = _react.useCallback(()=>{
        if (isDayPickerVisible && dayPicker.current) {
            (0, _utils.focusAsync)(dayPicker.current, win);
        } else if (isMonthPickerVisible && monthPicker.current) {
            (0, _utils.focusAsync)(monthPicker.current, win);
        }
    }, [
        isDayPickerVisible,
        isMonthPickerVisible,
        win
    ]);
    _react.useImperativeHandle(componentRef, ()=>({
            focus
        }), [
        focus
    ]);
    _react.useEffect(()=>{
        if (focusOnUpdate.current) {
            focus();
            focusOnUpdate.current = false;
        }
    });
    const focusOnNextUpdate = ()=>{
        focusOnUpdate.current = true;
    };
    return [
        dayPicker,
        monthPicker,
        focusOnNextUpdate
    ];
}
const Calendar = /*#__PURE__*/ _react.forwardRef((props, forwardedRef)=>{
    const { allFocusable = false, calendarDayProps, calendarMonthProps, className, componentRef, dateRangeType = _utils.DateRangeType.Day, dateTimeFormatter = _utils.DEFAULT_DATE_FORMATTING, firstDayOfWeek = _utils.DayOfWeek.Sunday, firstWeekOfYear = _utils.FirstWeekOfYear.FirstDay, highlightCurrentMonth = false, highlightSelectedMonth = false, id, isDayPickerVisible: isDayPickerVisibleProp = true, isMonthPickerVisible: isMonthPickerVisibleProp = true, maxDate, minDate, onDismiss, onSelectDate, restrictedDates, showCloseButton = false, showGoToToday = true, showMonthPickerAsOverlay: showMonthPickerAsOverlayProp = false, showSixWeeksByDefault = false, showWeekNumbers = false, strings = _utils.DEFAULT_CALENDAR_STRINGS, today: todayProp, value, workWeekDays = defaultWorkWeekDays } = props;
    const today = _react.useMemo(()=>{
        return todayProp !== null && todayProp !== void 0 ? todayProp : new Date();
    }, [
        todayProp
    ]);
    const [selectedDate, navigatedDay, navigatedMonth, onDateSelected, navigateDay, navigateMonth] = useDateState({
        onSelectDate,
        value,
        today
    });
    const [isMonthPickerVisible, isDayPickerVisible, toggleDayMonthPickerVisibility] = useVisibilityState({
        isDayPickerVisible: isDayPickerVisibleProp,
        isMonthPickerVisible: isMonthPickerVisibleProp,
        showMonthPickerAsOverlay: showMonthPickerAsOverlayProp
    });
    const [dayPicker, monthPicker, focusOnNextUpdate] = useFocusLogic({
        componentRef
    }, isDayPickerVisible, isMonthPickerVisible);
    const renderGoToTodayButton = ()=>{
        let goTodayEnabled = showGoToToday;
        if (goTodayEnabled && today) {
            goTodayEnabled = navigatedDay.getFullYear() !== today.getFullYear() || navigatedDay.getMonth() !== today.getMonth() || navigatedMonth.getFullYear() !== today.getFullYear() || navigatedMonth.getMonth() !== today.getMonth();
        }
        return showGoToToday && /*#__PURE__*/ _react.createElement("button", {
            className: classes.goTodayButton,
            onClick: onGotoToday,
            onKeyDown: onButtonKeyDown(onGotoToday),
            type: "button",
            disabled: !goTodayEnabled
        }, strings.goToToday);
    };
    const onNavigateDayDate = (date, focusOnNavigatedDay)=>{
        navigateDay(date);
        if (focusOnNavigatedDay) {
            focusOnNextUpdate();
        }
    };
    const onNavigateMonthDate = (date, focusOnNavigatedDay)=>{
        if (focusOnNavigatedDay) {
            focusOnNextUpdate();
        }
        if (!focusOnNavigatedDay) {
            navigateMonth(date);
            return;
        }
        if (monthPickerOnly) {
            onDateSelected(date);
        }
        navigateDay(date);
    };
    const showMonthPickerAsOverlay = useShowMonthPickerAsOverlay({
        isDayPickerVisible: isDayPickerVisibleProp,
        showMonthPickerAsOverlay: showMonthPickerAsOverlayProp
    });
    const onHeaderSelect = showMonthPickerAsOverlay ? ()=>{
        toggleDayMonthPickerVisibility();
        focusOnNextUpdate();
    } : undefined;
    const onGotoToday = ()=>{
        navigateDay(today);
        if (showMonthPickerAsOverlay && isMonthPickerVisible) {
            toggleDayMonthPickerVisibility();
        }
        focusOnNextUpdate();
    };
    const onButtonKeyDown = (callback)=>{
        return (ev)=>{
            switch(ev.key){
                case _keyboardkeys.Enter:
                case _keyboardkeys.Space:
                    callback();
                    break;
            }
        };
    };
    const onDatePickerPopupKeyDown = (ev)=>{
        switch(ev.key){
            case _keyboardkeys.Enter:
                ev.preventDefault();
                break;
            case _keyboardkeys.Backspace:
                ev.preventDefault();
                break;
            case _keyboardkeys.Escape:
                ev.stopPropagation();
                onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
                break;
            case _keyboardkeys.PageUp:
                if (ev.ctrlKey) {
                    // go to next year
                    navigateDay((0, _utils.addYears)(navigatedDay, 1));
                } else {
                    // go to next month
                    navigateDay((0, _utils.addMonths)(navigatedDay, 1));
                }
                ev.preventDefault();
                break;
            case _keyboardkeys.PageDown:
                if (ev.ctrlKey) {
                    // go to previous year
                    navigateDay((0, _utils.addYears)(navigatedDay, -1));
                } else {
                    // go to previous month
                    navigateDay((0, _utils.addMonths)(navigatedDay, -1));
                }
                ev.preventDefault();
                break;
            default:
                break;
        }
    };
    const monthPickerOnly = !showMonthPickerAsOverlay && !isDayPickerVisible;
    const classes = (0, _useCalendarStylesstyles.useCalendarStyles_unstable)({
        className,
        isDayPickerVisible,
        isMonthPickerVisible,
        showWeekNumbers
    });
    let todayDateString = '';
    let selectedDateString = '';
    if (dateTimeFormatter && strings.todayDateFormatString) {
        todayDateString = strings.todayDateFormatString.replace('{0}', dateTimeFormatter.formatMonthDayYear(today, strings));
    }
    if (dateTimeFormatter && strings.selectedDateFormatString) {
        const dateStringFormatter = monthPickerOnly ? dateTimeFormatter.formatMonthYear : dateTimeFormatter.formatMonthDayYear;
        selectedDateString = strings.selectedDateFormatString.replace('{0}', dateStringFormatter(selectedDate, strings));
    }
    const selectionAndTodayString = selectedDateString + ', ' + todayDateString;
    return /*#__PURE__*/ _react.createElement("div", {
        id: id,
        ref: forwardedRef,
        className: classes.root,
        onKeyDown: onDatePickerPopupKeyDown
    }, /*#__PURE__*/ _react.createElement("div", {
        className: classes.liveRegion,
        "aria-live": "polite",
        "aria-atomic": "true"
    }, /*#__PURE__*/ _react.createElement("span", null, selectedDateString)), isDayPickerVisible && /*#__PURE__*/ _react.createElement(_CalendarDay.CalendarDay, {
        gridLabel: selectionAndTodayString,
        selectedDate: selectedDate,
        navigatedDate: navigatedDay,
        today: today,
        onSelectDate: onDateSelected,
        // eslint-disable-next-line react/jsx-no-bind
        onNavigateDate: onNavigateDayDate,
        onDismiss: onDismiss,
        firstDayOfWeek: firstDayOfWeek,
        dateRangeType: dateRangeType,
        strings: strings,
        // eslint-disable-next-line react/jsx-no-bind
        onHeaderSelect: onHeaderSelect,
        showWeekNumbers: showWeekNumbers,
        firstWeekOfYear: firstWeekOfYear,
        dateTimeFormatter: dateTimeFormatter,
        showSixWeeksByDefault: showSixWeeksByDefault,
        minDate: minDate,
        maxDate: maxDate,
        navigationIcons: _calendarNavigationIcons.defaultNavigationIcons,
        restrictedDates: restrictedDates,
        workWeekDays: workWeekDays,
        componentRef: dayPicker,
        showCloseButton: showCloseButton,
        allFocusable: allFocusable,
        ...calendarDayProps
    }), isDayPickerVisible && isMonthPickerVisible && /*#__PURE__*/ _react.createElement("div", {
        className: classes.divider
    }), isMonthPickerVisible ? /*#__PURE__*/ _react.createElement("div", {
        className: classes.monthPickerWrapper
    }, /*#__PURE__*/ _react.createElement(_CalendarMonth.CalendarMonth, {
        navigatedDate: navigatedMonth,
        selectedDate: navigatedDay,
        strings: strings,
        // eslint-disable-next-line react/jsx-no-bind
        onNavigateDate: onNavigateMonthDate,
        today: today,
        highlightCurrentMonth: highlightCurrentMonth,
        highlightSelectedMonth: highlightSelectedMonth,
        // eslint-disable-next-line react/jsx-no-bind
        onHeaderSelect: onHeaderSelect,
        dateTimeFormatter: dateTimeFormatter,
        minDate: minDate,
        maxDate: maxDate,
        componentRef: monthPicker,
        navigationIcons: _calendarNavigationIcons.defaultNavigationIcons,
        ...calendarMonthProps
    }), renderGoToTodayButton()) : renderGoToTodayButton());
});
Calendar.displayName = 'Calendar';
const useShowMonthPickerAsOverlay = ({ isDayPickerVisible, showMonthPickerAsOverlay })=>{
    const { targetDocument } = (0, _reactsharedcontexts.useFluent_unstable)();
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    return showMonthPickerAsOverlay || isDayPickerVisible && win && win.innerWidth <= MIN_SIZE_FORCE_OVERLAY;
};
