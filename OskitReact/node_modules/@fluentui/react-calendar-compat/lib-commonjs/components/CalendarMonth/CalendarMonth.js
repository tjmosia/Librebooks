"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CalendarMonth", {
    enumerable: true,
    get: function() {
        return CalendarMonth;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _keyboardkeys = require("@fluentui/keyboard-keys");
const _reacttabster = require("@fluentui/react-tabster");
const _react1 = require("@griffel/react");
const _utils = require("../../utils");
const _CalendarYear = require("../CalendarYear/CalendarYear");
const _useCalendarMonthStylesstyles = require("./useCalendarMonthStyles.styles");
const MONTHS_PER_ROW = 4;
function useAnimateBackwards({ navigatedDate }) {
    const currentYear = navigatedDate.getFullYear();
    const previousYearRef = _react.useRef();
    _react.useEffect(()=>{
        previousYearRef.current = currentYear;
    });
    const previousYear = previousYearRef.current;
    if (previousYear === undefined || previousYear === currentYear) {
        return undefined;
    } else {
        return previousYear > currentYear;
    }
}
function useFocusLogic({ componentRef }) {
    const navigatedMonthRef = _react.useRef(null);
    const calendarYearRef = _react.useRef(null);
    const focusOnUpdate = _react.useRef(false);
    const focus = _react.useCallback(()=>{
        if (calendarYearRef.current) {
            calendarYearRef.current.focus();
        } else if (navigatedMonthRef.current) {
            navigatedMonthRef.current.focus();
        }
    }, []);
    _react.useImperativeHandle(componentRef, ()=>({
            focus
        }), [
        focus
    ]);
    _react.useEffect(()=>{
        if (focusOnUpdate.current) {
            focus();
            focusOnUpdate.current = false;
        }
    });
    const focusOnNextUpdate = ()=>{
        focusOnUpdate.current = true;
    };
    return [
        navigatedMonthRef,
        calendarYearRef,
        focusOnNextUpdate
    ];
}
const CalendarMonth = (props)=>{
    const { allFocusable, animationDirection, className, componentRef, dateTimeFormatter = _utils.DEFAULT_DATE_FORMATTING, highlightCurrentMonth, highlightSelectedMonth, maxDate, minDate, navigatedDate, navigationIcons, onHeaderSelect: onUserHeaderSelect, onNavigateDate, selectedDate, strings, today = new Date(), yearPickerHidden = false } = props;
    const [navigatedMonthRef, calendarYearRef, focusOnNextUpdate] = useFocusLogic({
        componentRef
    });
    const [isYearPickerVisible, setIsYearPickerVisible] = _react.useState(false);
    const animateBackwards = useAnimateBackwards({
        navigatedDate
    });
    const selectMonthCallback = (newMonth)=>{
        return ()=>onSelectMonth(newMonth);
    };
    const onSelectNextYear = ()=>{
        onNavigateDate((0, _utils.addYears)(navigatedDate, 1), false);
    };
    const onSelectPrevYear = ()=>{
        onNavigateDate((0, _utils.addYears)(navigatedDate, -1), false);
    };
    const onSelectMonth = (newMonth)=>{
        // If header is clickable the calendars are overlayed, switch back to day picker when month is clicked
        onUserHeaderSelect === null || onUserHeaderSelect === void 0 ? void 0 : onUserHeaderSelect();
        onNavigateDate((0, _utils.setMonth)(navigatedDate, newMonth), true);
    };
    const onHeaderSelect = ()=>{
        if (!yearPickerHidden) {
            focusOnNextUpdate();
            setIsYearPickerVisible(true);
        } else {
            onUserHeaderSelect === null || onUserHeaderSelect === void 0 ? void 0 : onUserHeaderSelect();
        }
    };
    const onSelectYear = (selectedYear)=>{
        focusOnNextUpdate();
        const navYear = navigatedDate.getFullYear();
        if (navYear !== selectedYear) {
            let newNavigationDate = new Date(navigatedDate.getTime());
            newNavigationDate.setFullYear(selectedYear);
            // for min and max dates, adjust the new navigation date - perhaps this should be
            // checked on the master navigation date handler (i.e. in Calendar)
            if (maxDate && newNavigationDate > maxDate) {
                newNavigationDate = (0, _utils.setMonth)(newNavigationDate, maxDate.getMonth());
            } else if (minDate && newNavigationDate < minDate) {
                newNavigationDate = (0, _utils.setMonth)(newNavigationDate, minDate.getMonth());
            }
            onNavigateDate(newNavigationDate, true);
        }
        setIsYearPickerVisible(false);
    };
    const onYearPickerHeaderSelect = (focus)=>{
        focusOnNextUpdate();
        setIsYearPickerVisible(false);
    };
    const dateFormatter = dateTimeFormatter;
    // determine if previous/next years are in bounds
    const isPrevYearInBounds = minDate ? (0, _utils.compareDatePart)(minDate, (0, _utils.getYearStart)(navigatedDate)) < 0 : true;
    const isNextYearInBounds = maxDate ? (0, _utils.compareDatePart)((0, _utils.getYearEnd)(navigatedDate), maxDate) < 0 : true;
    const classNames = (0, _useCalendarMonthStylesstyles.useCalendarMonthStyles_unstable)({
        className,
        hasHeaderClickCallback: !!onUserHeaderSelect || !yearPickerHidden,
        highlightCurrent: highlightCurrentMonth,
        highlightSelected: highlightSelectedMonth,
        animateBackwards,
        animationDirection
    });
    const arrowNavigationAttributes = (0, _reacttabster.useArrowNavigationGroup)({
        axis: 'grid'
    });
    if (isYearPickerVisible) {
        const [onRenderYear, yearStrings] = getYearStrings({
            dateTimeFormatter,
            navigatedDate,
            strings
        });
        // use navigated date for the year picker
        return /*#__PURE__*/ _react.createElement(_CalendarYear.CalendarYear, {
            key: 'calendarYear',
            minYear: minDate ? minDate.getFullYear() : undefined,
            maxYear: maxDate ? maxDate.getFullYear() : undefined,
            // eslint-disable-next-line react/jsx-no-bind
            onSelectYear: onSelectYear,
            // eslint-disable-next-line react/jsx-no-bind
            onHeaderSelect: onYearPickerHeaderSelect,
            selectedYear: selectedDate ? selectedDate.getFullYear() : navigatedDate ? navigatedDate.getFullYear() : undefined,
            navigatedYear: navigatedDate.getFullYear(),
            navigationIcons: navigationIcons,
            onRenderYear: onRenderYear,
            strings: yearStrings,
            componentRef: calendarYearRef,
            highlightCurrentYear: highlightCurrentMonth,
            highlightSelectedYear: highlightSelectedMonth,
            animationDirection: animationDirection
        });
    }
    const rowIndexes = [];
    for(let i = 0; i < strings.shortMonths.length / MONTHS_PER_ROW; i++){
        rowIndexes.push(i);
    }
    const yearString = dateFormatter.formatYear(navigatedDate);
    const headerAriaLabel = strings.monthPickerHeaderAriaLabel ? strings.monthPickerHeaderAriaLabel.replace('{0}', yearString) : yearString;
    return /*#__PURE__*/ _react.createElement("div", {
        className: classNames.root
    }, /*#__PURE__*/ _react.createElement("div", {
        className: classNames.headerContainer
    }, /*#__PURE__*/ _react.createElement("button", {
        className: classNames.currentItemButton,
        onClick: onHeaderSelect,
        onKeyDown: onButtonKeyDown(onHeaderSelect),
        "aria-label": headerAriaLabel,
        tabIndex: !!onUserHeaderSelect || !yearPickerHidden ? 0 : -1,
        type: "button"
    }, /*#__PURE__*/ _react.createElement("span", {
        "aria-live": "polite",
        "aria-atomic": "true"
    }, yearString)), /*#__PURE__*/ _react.createElement("div", {
        className: classNames.navigationButtonsContainer
    }, /*#__PURE__*/ _react.createElement("button", {
        className: (0, _react1.mergeClasses)(classNames.navigationButton, !isPrevYearInBounds && classNames.disabled),
        "aria-disabled": !isPrevYearInBounds,
        tabIndex: isPrevYearInBounds ? undefined : allFocusable ? 0 : -1,
        onClick: isPrevYearInBounds ? onSelectPrevYear : undefined,
        onKeyDown: isPrevYearInBounds ? onButtonKeyDown(onSelectPrevYear) : undefined,
        title: strings.prevYearAriaLabel ? strings.prevYearAriaLabel + ' ' + dateFormatter.formatYear((0, _utils.addYears)(navigatedDate, -1)) : undefined,
        type: "button"
    }, navigationIcons.upNavigation), /*#__PURE__*/ _react.createElement("button", {
        className: (0, _react1.mergeClasses)(classNames.navigationButton, !isNextYearInBounds && classNames.disabled),
        "aria-disabled": !isNextYearInBounds,
        tabIndex: isNextYearInBounds ? undefined : allFocusable ? 0 : -1,
        onClick: isNextYearInBounds ? onSelectNextYear : undefined,
        onKeyDown: isNextYearInBounds ? onButtonKeyDown(onSelectNextYear) : undefined,
        title: strings.nextYearAriaLabel ? strings.nextYearAriaLabel + ' ' + dateFormatter.formatYear((0, _utils.addYears)(navigatedDate, 1)) : undefined,
        type: "button"
    }, navigationIcons.downNavigation))), /*#__PURE__*/ _react.createElement("div", {
        ...arrowNavigationAttributes,
        className: classNames.gridContainer,
        role: "grid",
        "aria-label": yearString
    }, rowIndexes.map((rowNum)=>{
        const monthsForRow = strings.shortMonths.slice(rowNum * MONTHS_PER_ROW, (rowNum + 1) * MONTHS_PER_ROW);
        return /*#__PURE__*/ _react.createElement("div", {
            key: 'monthRow_' + rowNum + navigatedDate.getFullYear(),
            role: "row",
            className: classNames.buttonRow
        }, monthsForRow.map((month, index)=>{
            const monthIndex = rowNum * MONTHS_PER_ROW + index;
            const indexedMonth = (0, _utils.setMonth)(navigatedDate, monthIndex);
            const isNavigatedMonth = navigatedDate.getMonth() === monthIndex;
            const isSelectedMonth = selectedDate.getMonth() === monthIndex;
            const isSelectedYear = selectedDate.getFullYear() === navigatedDate.getFullYear();
            const isInBounds = (minDate ? (0, _utils.compareDatePart)(minDate, (0, _utils.getMonthEnd)(indexedMonth)) < 1 : true) && (maxDate ? (0, _utils.compareDatePart)((0, _utils.getMonthStart)(indexedMonth), maxDate) < 1 : true);
            return /*#__PURE__*/ _react.createElement("button", {
                ref: isNavigatedMonth ? navigatedMonthRef : undefined,
                role: 'gridcell',
                className: (0, _react1.mergeClasses)(classNames.itemButton, highlightCurrentMonth && isCurrentMonth(monthIndex, navigatedDate.getFullYear(), today) && classNames.current, highlightSelectedMonth && isSelectedMonth && isSelectedYear && classNames.selected, !isInBounds && classNames.disabled),
                disabled: !allFocusable && !isInBounds,
                key: monthIndex,
                onClick: isInBounds ? selectMonthCallback(monthIndex) : undefined,
                onKeyDown: isInBounds ? onButtonKeyDown(selectMonthCallback(monthIndex)) : undefined,
                "aria-label": dateFormatter.formatMonth(indexedMonth, strings),
                "aria-selected": isNavigatedMonth,
                tabIndex: isInBounds ? 0 : -1,
                type: "button"
            }, month);
        }));
    })));
};
CalendarMonth.displayName = 'CalendarMonth';
function getYearStrings({ dateTimeFormatter, navigatedDate, strings }) {
    const yearToString = (year)=>{
        if (dateTimeFormatter) {
            // create a date based on the current nav date
            const yearFormattingDate = new Date(navigatedDate.getTime());
            yearFormattingDate.setFullYear(year);
            return dateTimeFormatter.formatYear(yearFormattingDate);
        }
        return String(year);
    };
    const yearRangeToString = (yearRange)=>{
        return `${yearToString(yearRange.fromYear)} - ${yearToString(yearRange.toYear)}`;
    };
    const yearRangeToNextDecadeLabel = (yearRange)=>{
        return strings.nextYearRangeAriaLabel ? `${strings.nextYearRangeAriaLabel} ${yearRangeToString(yearRange)}` : '';
    };
    const yearRangeToPrevDecadeLabel = (yearRange)=>{
        return strings.prevYearRangeAriaLabel ? `${strings.prevYearRangeAriaLabel} ${yearRangeToString(yearRange)}` : '';
    };
    return [
        yearToString,
        {
            rangeAriaLabel: yearRangeToString,
            prevRangeAriaLabel: yearRangeToPrevDecadeLabel,
            nextRangeAriaLabel: yearRangeToNextDecadeLabel,
            headerAriaLabelFormatString: strings.yearPickerHeaderAriaLabel
        }
    ];
}
function isCurrentMonth(month, year, today) {
    return today.getFullYear() === year && today.getMonth() === month;
}
function onButtonKeyDown(callback) {
    return (ev)=>{
        switch(ev.key){
            case _keyboardkeys.Enter:
                callback();
                break;
        }
    };
}
