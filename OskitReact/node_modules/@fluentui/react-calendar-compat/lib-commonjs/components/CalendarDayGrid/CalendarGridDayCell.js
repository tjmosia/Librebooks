"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CalendarGridDayCell", {
    enumerable: true,
    get: function() {
        return CalendarGridDayCell;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _keyboardkeys = require("@fluentui/keyboard-keys");
const _reactutilities = require("@fluentui/react-utilities");
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _react1 = require("@griffel/react");
const _utils = require("../../utils");
const _useWeekCornerStylesstyles = require("./useWeekCornerStyles.styles");
const _useCalendarDayGridStylesstyles = require("./useCalendarDayGridStyles.styles");
const CalendarGridDayCell = (props)=>{
    'use no memo';
    const { navigatedDate, dateTimeFormatter, allFocusable, strings, activeDescendantId, navigatedDayRef, calculateRoundedStyles, weeks, classNames, day, dayIndex, weekIndex, weekCorners, ariaHidden, customDayCellRef, dateRangeType, daysToSelectInDayView, onSelectDate, restrictedDates, minDate, maxDate, onNavigateDate, getDayInfosInRangeOfDay, getRefsFromDayInfos } = props;
    var _weekCorners_;
    const cornerStyle = (_weekCorners_ = weekCorners === null || weekCorners === void 0 ? void 0 : weekCorners[weekIndex + '_' + dayIndex]) !== null && _weekCorners_ !== void 0 ? _weekCorners_ : '';
    const isNavigatedDate = (0, _utils.compareDates)(navigatedDate, day.originalDate);
    const { dir } = (0, _reactsharedcontexts.useFluent_unstable)();
    const navigateMonthEdge = (ev, date)=>{
        let targetDate = undefined;
        let direction = 1; // by default search forward
        if (ev.key === _keyboardkeys.ArrowUp) {
            targetDate = (0, _utils.addWeeks)(date, -1);
            direction = -1;
        } else if (ev.key === _keyboardkeys.ArrowDown) {
            targetDate = (0, _utils.addWeeks)(date, 1);
        } else if (ev.key === (0, _reactutilities.getRTLSafeKey)(_keyboardkeys.ArrowLeft, dir)) {
            targetDate = (0, _utils.addDays)(date, -1);
            direction = -1;
        } else if (ev.key === (0, _reactutilities.getRTLSafeKey)(_keyboardkeys.ArrowRight, dir)) {
            targetDate = (0, _utils.addDays)(date, 1);
        }
        if (!targetDate) {
            // if we couldn't find a target date at all, do nothing
            return;
        }
        const findAvailableDateOptions = {
            initialDate: date,
            targetDate,
            direction,
            restrictedDates,
            minDate,
            maxDate
        };
        // target date is restricted, search in whatever direction until finding the next possible date,
        // stopping at boundaries
        let nextDate = (0, _utils.findAvailableDate)(findAvailableDateOptions);
        if (!nextDate) {
            // if no dates available in initial direction, try going backwards
            findAvailableDateOptions.direction = -direction;
            nextDate = (0, _utils.findAvailableDate)(findAvailableDateOptions);
        }
        // if the nextDate is still inside the same focusZone area, let the focusZone handle setting the focus so we
        // don't jump the view unnecessarily
        const isInCurrentView = weeks && nextDate && weeks.slice(1, weeks.length - 1).some((week)=>{
            return week.some((dayToCompare)=>{
                return (0, _utils.compareDates)(dayToCompare.originalDate, nextDate);
            });
        });
        if (isInCurrentView) {
            return;
        }
        // else, fire navigation on the date to change the view to show it
        if (nextDate) {
            onNavigateDate(nextDate, true);
            ev.preventDefault();
        }
    };
    const onMouseOverDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef, index)=>{
            if (dayRef) {
                dayRef.classList.add(_useCalendarDayGridStylesstyles.extraCalendarDayGridClassNames.hoverStyle);
                if (!dayInfos[index].isSelected && dateRangeType === _utils.DateRangeType.Day && daysToSelectInDayView && daysToSelectInDayView > 1) {
                    // remove the static classes first to overwrite them
                    dayRef.classList.remove(_useWeekCornerStylesstyles.weekCornersClassNames.bottomLeftCornerDate, _useWeekCornerStylesstyles.weekCornersClassNames.bottomRightCornerDate, _useWeekCornerStylesstyles.weekCornersClassNames.topLeftCornerDate, _useWeekCornerStylesstyles.weekCornersClassNames.topRightCornerDate);
                    const classNamesToAdd = calculateRoundedStyles(false, false, index > 0, index < dayRefs.length - 1).trim();
                    if (classNamesToAdd) {
                        dayRef.classList.add(...classNamesToAdd.trim().split(' '));
                    }
                }
            }
        });
    };
    const onMouseDownDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef)=>{
            if (dayRef) {
                dayRef.classList.add(_useCalendarDayGridStylesstyles.extraCalendarDayGridClassNames.pressedStyle);
            }
        });
    };
    const onMouseUpDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef)=>{
            if (dayRef) {
                dayRef.classList.remove(_useCalendarDayGridStylesstyles.extraCalendarDayGridClassNames.pressedStyle);
            }
        });
    };
    const onMouseOutDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef, index)=>{
            if (dayRef) {
                dayRef.classList.remove(_useCalendarDayGridStylesstyles.extraCalendarDayGridClassNames.hoverStyle);
                dayRef.classList.remove(_useCalendarDayGridStylesstyles.extraCalendarDayGridClassNames.pressedStyle);
                if (!dayInfos[index].isSelected && dateRangeType === _utils.DateRangeType.Day && daysToSelectInDayView && daysToSelectInDayView > 1) {
                    const classNamesToAdd = calculateRoundedStyles(false, false, index > 0, index < dayRefs.length - 1).trim();
                    if (classNamesToAdd) {
                        dayRef.classList.remove(...classNamesToAdd.trim().split(' '));
                    }
                }
            }
        });
    };
    const onDayKeyDown = (ev)=>{
        if (ev.key === _keyboardkeys.Enter) {
            onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(day.originalDate);
        } else {
            navigateMonthEdge(ev, day.originalDate);
        }
    };
    let ariaLabel = day.originalDate.getDate() + ', ' + strings.months[day.originalDate.getMonth()] + ', ' + day.originalDate.getFullYear();
    if (day.isMarked) {
        ariaLabel = ariaLabel + ', ' + strings.dayMarkedAriaLabel;
    }
    const isFocusable = !ariaHidden && (allFocusable || (day.isInBounds ? true : undefined));
    return /*#__PURE__*/ _react.createElement("td", {
        className: (0, _react1.mergeClasses)(classNames.dayCell, weekCorners && cornerStyle, day.isSelected && !day.isSingleSelected && classNames.daySelected, day.isSingleSelected && classNames.daySingleSelected, !day.isInBounds && classNames.dayOutsideBounds, !day.isInMonth && classNames.dayOutsideNavigatedMonth),
        ref: (element)=>{
            customDayCellRef === null || customDayCellRef === void 0 ? void 0 : customDayCellRef(element, day.originalDate, classNames);
            day.setRef(element);
            isNavigatedDate && (navigatedDayRef.current = element);
        },
        "aria-disabled": !ariaHidden && !day.isInBounds,
        onClick: day.isInBounds && !ariaHidden ? day.onSelected : undefined,
        onMouseOver: !ariaHidden ? onMouseOverDay : undefined,
        onMouseDown: !ariaHidden ? onMouseDownDay : undefined,
        onMouseUp: !ariaHidden ? onMouseUpDay : undefined,
        onMouseOut: !ariaHidden ? onMouseOutDay : undefined,
        onKeyDown: !ariaHidden ? onDayKeyDown : undefined,
        role: "gridcell",
        tabIndex: isNavigatedDate || isFocusable ? 0 : undefined,
        "aria-current": day.isToday ? 'date' : undefined,
        "aria-selected": day.isInBounds ? day.isSelected : undefined
    }, /*#__PURE__*/ _react.createElement("button", {
        key: day.key + 'button',
        className: (0, _react1.mergeClasses)(classNames.dayButton, day.isToday && classNames.dayIsToday),
        "aria-label": ariaLabel,
        id: isNavigatedDate ? activeDescendantId : undefined,
        disabled: !ariaHidden && !day.isInBounds,
        type: "button",
        tabIndex: -1
    }, /*#__PURE__*/ _react.createElement("span", {
        className: day.isToday ? (0, _react1.mergeClasses)(classNames.dayTodayMarker) : undefined
    }, dateTimeFormatter.formatDay(day.originalDate)), day.isMarked && /*#__PURE__*/ _react.createElement("div", {
        "aria-hidden": "true",
        className: classNames.dayMarker
    })));
};
