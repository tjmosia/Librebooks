"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CalendarDayGrid", {
    enumerable: true,
    get: function() {
        return CalendarDayGrid;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reacttabster = require("@fluentui/react-tabster");
const _reactutilities = require("@fluentui/react-utilities");
const _utils = require("../../utils");
const _useCalendarDayGridStylesstyles = require("./useCalendarDayGridStyles.styles");
const _CalendarMonthHeaderRow = require("./CalendarMonthHeaderRow");
const _CalendarGridRow = require("./CalendarGridRow");
const _useWeeks = require("./useWeeks");
const _useWeekCornerStylesstyles = require("./useWeekCornerStyles.styles");
const _react1 = require("@griffel/react");
function useDayRefs() {
    const daysRef = _react.useRef({});
    const getSetRefCallback = (dayKey)=>(element)=>{
            if (element === null) {
                delete daysRef.current[dayKey];
            } else {
                daysRef.current[dayKey] = element;
            }
        };
    return [
        daysRef,
        getSetRefCallback
    ];
}
function useAnimateBackwards(weeks) {
    const previousNavigatedDateRef = _react.useRef();
    _react.useEffect(()=>{
        previousNavigatedDateRef.current = weeks[0][0].originalDate;
    });
    const previousNavigatedDate = previousNavigatedDateRef.current;
    if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {
        return undefined;
    } else if (previousNavigatedDate <= weeks[0][0].originalDate) {
        return false;
    } else {
        return true;
    }
}
const CalendarDayGrid = (props)=>{
    const navigatedDayRef = _react.useRef(null);
    const activeDescendantId = (0, _reactutilities.useId)();
    const onSelectDate = (selectedDate)=>{
        var _props_onSelectDate, _props_onNavigateDate;
        const { firstDayOfWeek, minDate, maxDate, workWeekDays, daysToSelectInDayView, restrictedDates } = props;
        const restrictedDatesOptions = {
            minDate,
            maxDate,
            restrictedDates
        };
        let dateRange = (0, _utils.getDateRangeArray)(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);
        dateRange = (0, _utils.getBoundedDateRange)(dateRange, minDate, maxDate);
        dateRange = dateRange.filter((d)=>{
            return !(0, _utils.isRestrictedDate)(d, restrictedDatesOptions);
        });
        (_props_onSelectDate = props.onSelectDate) === null || _props_onSelectDate === void 0 ? void 0 : _props_onSelectDate.call(props, selectedDate, dateRange);
        (_props_onNavigateDate = props.onNavigateDate) === null || _props_onNavigateDate === void 0 ? void 0 : _props_onNavigateDate.call(props, selectedDate, true);
    };
    const [daysRef, getSetRefCallback] = useDayRefs();
    const weeks = (0, _useWeeks.useWeeks)(props, onSelectDate, getSetRefCallback);
    const animateBackwards = useAnimateBackwards(weeks);
    const [getWeekCornerStyles, calculateRoundedStyles] = (0, _useWeekCornerStylesstyles.useWeekCornerStyles)(props);
    _react.useImperativeHandle(props.componentRef, ()=>({
            focus () {
                var _navigatedDayRef_current_focus, _navigatedDayRef_current;
                (_navigatedDayRef_current = navigatedDayRef.current) === null || _navigatedDayRef_current === void 0 ? void 0 : (_navigatedDayRef_current_focus = _navigatedDayRef_current.focus) === null || _navigatedDayRef_current_focus === void 0 ? void 0 : _navigatedDayRef_current_focus.call(_navigatedDayRef_current);
            }
        }), []);
    /**
   *
   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support
   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks
   * to set classnames on all relevant child refs to apply the styling
   *
   */ const getDayInfosInRangeOfDay = (dayToCompare)=>{
        // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state
        const dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);
        // gets all the dates for the given date range type that are in the same date range as the given day
        const dateRange = (0, _utils.getDateRangeArray)(dayToCompare.originalDate, dateRangeHoverType, props.firstDayOfWeek, props.workWeekDays, props.daysToSelectInDayView).map((date)=>date.getTime());
        // gets all the day refs for the given dates
        const dayInfosInRange = weeks.reduce((accumulatedValue, currentWeek)=>{
            return accumulatedValue.concat(currentWeek.filter((weekDay)=>dateRange.indexOf(weekDay.originalDate.getTime()) !== -1));
        }, []);
        return dayInfosInRange;
    };
    const getRefsFromDayInfos = (dayInfosInRange)=>{
        let dayRefs = [];
        dayRefs = dayInfosInRange.map((dayInfo)=>daysRef.current[dayInfo.key]);
        return dayRefs;
    };
    const { gridLabel, dateRangeType, showWeekNumbers, labelledBy, lightenDaysOutsideNavigatedMonth, animationDirection } = props;
    const classNames = (0, _useCalendarDayGridStylesstyles.useCalendarDayGridStyles_unstable)({
        animateBackwards,
        animationDirection,
        dateRangeType,
        lightenDaysOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,
        showWeekNumbers
    });
    // When the month is highlighted get the corner dates so that styles can be added to them
    const weekCorners = getWeekCornerStyles(weeks);
    const partialWeekProps = {
        weeks,
        navigatedDayRef,
        calculateRoundedStyles,
        activeDescendantId,
        classNames,
        weekCorners,
        getDayInfosInRangeOfDay,
        getRefsFromDayInfos
    };
    const arrowNavigationAttributes = (0, _reacttabster.useArrowNavigationGroup)({
        axis: 'grid'
    });
    return /*#__PURE__*/ _react.createElement("table", {
        className: (0, _react1.mergeClasses)(classNames.table, props.className),
        "aria-multiselectable": "false",
        "aria-label": gridLabel,
        "aria-labelledby": labelledBy,
        "aria-activedescendant": activeDescendantId,
        role: "grid",
        ...arrowNavigationAttributes
    }, /*#__PURE__*/ _react.createElement("tbody", null, /*#__PURE__*/ _react.createElement(_CalendarMonthHeaderRow.CalendarMonthHeaderRow, {
        ...props,
        classNames: classNames,
        weeks: weeks
    }), /*#__PURE__*/ _react.createElement(_CalendarGridRow.CalendarGridRow, {
        ...props,
        ...partialWeekProps,
        week: weeks[0],
        weekIndex: -1,
        rowClassName: classNames.firstTransitionWeek,
        "aria-role": "presentation",
        ariaHidden: true
    }), weeks.slice(1, weeks.length - 1).map((week, weekIndex)=>/*#__PURE__*/ _react.createElement(_CalendarGridRow.CalendarGridRow, {
            ...props,
            ...partialWeekProps,
            key: weekIndex,
            week: week,
            weekIndex: weekIndex,
            rowClassName: classNames.weekRow
        })), /*#__PURE__*/ _react.createElement(_CalendarGridRow.CalendarGridRow, {
        ...props,
        ...partialWeekProps,
        week: weeks[weeks.length - 1],
        weekIndex: -2,
        rowClassName: classNames.lastTransitionWeek,
        "aria-role": "presentation",
        ariaHidden: true
    })));
};
CalendarDayGrid.displayName = 'CalendarDayGrid';
/**
 * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous
 * work weeks, we'll just show week view instead.
 */ function getDateRangeTypeToUse(dateRangeType, workWeekDays) {
    if (workWeekDays && dateRangeType === _utils.DateRangeType.WorkWeek) {
        const sortedWWDays = workWeekDays.slice().sort();
        let isContiguous = true;
        for(let i = 1; i < sortedWWDays.length; i++){
            if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {
                isContiguous = false;
                break;
            }
        }
        if (!isContiguous || workWeekDays.length === 0) {
            return _utils.DateRangeType.Week;
        }
    }
    return dateRangeType;
}
