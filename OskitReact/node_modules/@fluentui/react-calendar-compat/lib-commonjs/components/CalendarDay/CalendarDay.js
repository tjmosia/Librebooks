"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CalendarDay", {
    enumerable: true,
    get: function() {
        return CalendarDay;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _keyboardkeys = require("@fluentui/keyboard-keys");
const _react1 = require("@griffel/react");
const _utils = require("../../utils");
const _CalendarDayGrid = require("../CalendarDayGrid/CalendarDayGrid");
const _useCalendarDayStylesstyles = require("./useCalendarDayStyles.styles");
const CalendarDay = (props)=>{
    const dayGrid = _react.useRef(null);
    _react.useImperativeHandle(props.componentRef, ()=>({
            focus () {
                var _dayGrid_current_focus, _dayGrid_current;
                (_dayGrid_current = dayGrid.current) === null || _dayGrid_current === void 0 ? void 0 : (_dayGrid_current_focus = _dayGrid_current.focus) === null || _dayGrid_current_focus === void 0 ? void 0 : _dayGrid_current_focus.call(_dayGrid_current);
            }
        }), []);
    const { strings, gridLabel, navigatedDate, dateTimeFormatter, className, onHeaderSelect, showSixWeeksByDefault, minDate, maxDate, restrictedDates, onNavigateDate, showWeekNumbers, dateRangeType, animationDirection } = props;
    const classNames = (0, _useCalendarDayStylesstyles.useCalendarDayStyles_unstable)({
        className,
        headerIsClickable: !!onHeaderSelect,
        showWeekNumbers,
        animationDirection
    });
    const monthAndYear = dateTimeFormatter.formatMonthYear(navigatedDate, strings);
    const HeaderButtonComponentType = onHeaderSelect ? 'button' : 'div';
    const headerAriaLabel = strings.yearPickerHeaderAriaLabel ? strings.yearPickerHeaderAriaLabel.replace('{0}', monthAndYear) : monthAndYear;
    const { ...propsWithoutStyles } = props;
    return /*#__PURE__*/ _react.createElement("div", {
        className: classNames.root
    }, /*#__PURE__*/ _react.createElement("div", {
        className: classNames.header
    }, /*#__PURE__*/ _react.createElement(HeaderButtonComponentType, {
        "aria-label": onHeaderSelect ? headerAriaLabel : undefined,
        className: classNames.monthAndYear,
        onClick: onHeaderSelect,
        tabIndex: onHeaderSelect ? 0 : -1,
        onKeyDown: onButtonKeyDown(onHeaderSelect),
        type: "button"
    }, /*#__PURE__*/ _react.createElement("span", {
        "aria-live": "polite",
        "aria-atomic": "true"
    }, monthAndYear)), /*#__PURE__*/ _react.createElement(CalendarDayNavigationButtons, {
        ...props,
        classNames: classNames
    })), /*#__PURE__*/ _react.createElement(_CalendarDayGrid.CalendarDayGrid, {
        ...propsWithoutStyles,
        gridLabel: `${monthAndYear}, ${gridLabel}`,
        componentRef: dayGrid,
        strings: strings,
        navigatedDate: navigatedDate,
        weeksToShow: showSixWeeksByDefault ? 6 : undefined,
        dateTimeFormatter: dateTimeFormatter,
        minDate: minDate,
        maxDate: maxDate,
        restrictedDates: restrictedDates,
        onNavigateDate: onNavigateDate,
        dateRangeType: dateRangeType
    }));
};
CalendarDay.displayName = 'CalendarDay';
const CalendarDayNavigationButtons = (props)=>{
    const { minDate, maxDate, navigatedDate, navigationIcons, allFocusable, strings, showCloseButton, classNames, onNavigateDate, onDismiss } = props;
    const onSelectNextMonth = ()=>{
        onNavigateDate((0, _utils.addMonths)(navigatedDate, 1), false);
    };
    const onSelectPrevMonth = ()=>{
        onNavigateDate((0, _utils.addMonths)(navigatedDate, -1), false);
    };
    // determine if previous/next months are in bounds
    const prevMonthInBounds = minDate ? (0, _utils.compareDatePart)(minDate, (0, _utils.getMonthStart)(navigatedDate)) < 0 : true;
    const nextMonthInBounds = maxDate ? (0, _utils.compareDatePart)((0, _utils.getMonthEnd)(navigatedDate), maxDate) < 0 : true;
    // use aria-disabled instead of disabled so focus is not lost
    // when a prev/next button becomes disabled after being clicked
    return /*#__PURE__*/ _react.createElement("div", {
        className: classNames.monthComponents
    }, /*#__PURE__*/ _react.createElement("button", {
        className: (0, _react1.mergeClasses)(classNames.headerIconButton, !prevMonthInBounds && classNames.disabledStyle),
        tabIndex: prevMonthInBounds ? undefined : allFocusable ? 0 : -1,
        "aria-disabled": !prevMonthInBounds,
        onClick: prevMonthInBounds ? onSelectPrevMonth : undefined,
        onKeyDown: prevMonthInBounds ? onButtonKeyDown(onSelectPrevMonth) : undefined,
        title: strings.prevMonthAriaLabel ? strings.prevMonthAriaLabel + ' ' + strings.months[(0, _utils.addMonths)(navigatedDate, -1).getMonth()] : undefined,
        type: "button"
    }, navigationIcons.upNavigation), /*#__PURE__*/ _react.createElement("button", {
        className: (0, _react1.mergeClasses)(classNames.headerIconButton, !nextMonthInBounds && classNames.disabledStyle),
        tabIndex: nextMonthInBounds ? undefined : allFocusable ? 0 : -1,
        "aria-disabled": !nextMonthInBounds,
        onClick: nextMonthInBounds ? onSelectNextMonth : undefined,
        onKeyDown: nextMonthInBounds ? onButtonKeyDown(onSelectNextMonth) : undefined,
        title: strings.nextMonthAriaLabel ? strings.nextMonthAriaLabel + ' ' + strings.months[(0, _utils.addMonths)(navigatedDate, 1).getMonth()] : undefined,
        type: "button"
    }, navigationIcons.downNavigation), showCloseButton && /*#__PURE__*/ _react.createElement("button", {
        className: classNames.headerIconButton,
        onClick: onDismiss,
        onKeyDown: onButtonKeyDown(onDismiss),
        title: strings.closeButtonAriaLabel,
        type: "button"
    }, navigationIcons.dismiss));
};
CalendarDayNavigationButtons.displayName = 'CalendarDayNavigationButtons';
const onButtonKeyDown = (callback)=>(ev)=>{
        switch(ev.key){
            case _keyboardkeys.Enter:
                callback === null || callback === void 0 ? void 0 : callback();
                break;
        }
    };
