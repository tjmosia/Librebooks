"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getDayGrid", {
    enumerable: true,
    get: function() {
        return getDayGrid;
    }
});
const _dateMath = require("../dateMath/dateMath");
const _constants = require("../constants");
const _getDateRangeTypeToUse = require("./getDateRangeTypeToUse");
const _getBoundedDateRange = require("./getBoundedDateRange");
const _isRestrictedDate = require("./isRestrictedDate");
const getDayGrid = (options)=>{
    const { selectedDate, dateRangeType, firstDayOfWeek, today, minDate, maxDate, weeksToShow, workWeekDays, daysToSelectInDayView, restrictedDates, markedDays } = options;
    const restrictedDateOptions = {
        minDate,
        maxDate,
        restrictedDates
    };
    const todaysDate = today || new Date();
    const navigatedDate = options.navigatedDate ? options.navigatedDate : todaysDate;
    let date;
    if (weeksToShow && weeksToShow <= 4) {
        // if showing less than a full month, just use date == navigatedDate
        date = new Date(navigatedDate.getFullYear(), navigatedDate.getMonth(), navigatedDate.getDate());
    } else {
        date = new Date(navigatedDate.getFullYear(), navigatedDate.getMonth(), 1);
    }
    const weeks = [];
    // Cycle the date backwards to get to the first day of the week.
    while(date.getDay() !== firstDayOfWeek){
        date.setDate(date.getDate() - 1);
    }
    // add the transition week as last week of previous range
    date = (0, _dateMath.addDays)(date, -_constants.DAYS_IN_WEEK);
    // a flag to indicate whether all days of the week are outside the month
    let isAllDaysOfWeekOutOfMonth = false;
    // in work week view if the days aren't contiguous we use week view instead
    const selectedDateRangeType = (0, _getDateRangeTypeToUse.getDateRangeTypeToUse)(dateRangeType, workWeekDays, firstDayOfWeek);
    let selectedDates = [];
    if (selectedDate) {
        selectedDates = (0, _dateMath.getDateRangeArray)(selectedDate, selectedDateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);
        selectedDates = (0, _getBoundedDateRange.getBoundedDateRange)(selectedDates, minDate, maxDate);
    }
    let shouldGetWeeks = true;
    for(let weekIndex = 0; shouldGetWeeks; weekIndex++){
        const week = [];
        isAllDaysOfWeekOutOfMonth = true;
        for(let dayIndex = 0; dayIndex < _constants.DAYS_IN_WEEK; dayIndex++){
            const originalDate = new Date(date.getTime());
            const dayInfo = {
                key: date.toString(),
                date: date.getDate().toString(),
                originalDate,
                isInMonth: date.getMonth() === navigatedDate.getMonth(),
                isToday: (0, _dateMath.compareDates)(todaysDate, date),
                isSelected: (0, _dateMath.isInDateRangeArray)(date, selectedDates),
                isSingleSelected: selectedDates.length === 1 && (0, _dateMath.compareDates)(date, selectedDate),
                isInBounds: !(0, _isRestrictedDate.isRestrictedDate)(date, restrictedDateOptions),
                isMarked: (markedDays === null || markedDays === void 0 ? void 0 : markedDays.some((markedDay)=>(0, _dateMath.compareDates)(originalDate, markedDay))) || false
            };
            week.push(dayInfo);
            if (dayInfo.isInMonth) {
                isAllDaysOfWeekOutOfMonth = false;
            }
            date.setDate(date.getDate() + 1);
        }
        // We append the condition of the loop depending upon the showSixWeeksByDefault prop.
        shouldGetWeeks = weeksToShow ? weekIndex < weeksToShow + 1 : !isAllDaysOfWeekOutOfMonth || weekIndex === 0;
        // we don't check shouldGetWeeks before pushing because we want to add one extra week for transition state
        weeks.push(week);
    }
    return weeks;
};
