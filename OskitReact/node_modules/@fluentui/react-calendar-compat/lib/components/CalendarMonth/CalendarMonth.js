import * as React from 'react';
import { Enter } from '@fluentui/keyboard-keys';
import { useArrowNavigationGroup } from '@fluentui/react-tabster';
import { mergeClasses } from '@griffel/react';
import { addYears, compareDatePart, getMonthEnd, getMonthStart, getYearEnd, getYearStart, setMonth, DEFAULT_DATE_FORMATTING } from '../../utils';
import { CalendarYear } from '../CalendarYear/CalendarYear';
import { useCalendarMonthStyles_unstable } from './useCalendarMonthStyles.styles';
const MONTHS_PER_ROW = 4;
function useAnimateBackwards({ navigatedDate }) {
    const currentYear = navigatedDate.getFullYear();
    const previousYearRef = React.useRef();
    React.useEffect(()=>{
        previousYearRef.current = currentYear;
    });
    const previousYear = previousYearRef.current;
    if (previousYear === undefined || previousYear === currentYear) {
        return undefined;
    } else {
        return previousYear > currentYear;
    }
}
function useFocusLogic({ componentRef }) {
    const navigatedMonthRef = React.useRef(null);
    const calendarYearRef = React.useRef(null);
    const focusOnUpdate = React.useRef(false);
    const focus = React.useCallback(()=>{
        if (calendarYearRef.current) {
            calendarYearRef.current.focus();
        } else if (navigatedMonthRef.current) {
            navigatedMonthRef.current.focus();
        }
    }, []);
    React.useImperativeHandle(componentRef, ()=>({
            focus
        }), [
        focus
    ]);
    React.useEffect(()=>{
        if (focusOnUpdate.current) {
            focus();
            focusOnUpdate.current = false;
        }
    });
    const focusOnNextUpdate = ()=>{
        focusOnUpdate.current = true;
    };
    return [
        navigatedMonthRef,
        calendarYearRef,
        focusOnNextUpdate
    ];
}
/**
 * @internal
 */ export const CalendarMonth = (props)=>{
    const { allFocusable, animationDirection, className, componentRef, dateTimeFormatter = DEFAULT_DATE_FORMATTING, highlightCurrentMonth, highlightSelectedMonth, maxDate, minDate, navigatedDate, navigationIcons, onHeaderSelect: onUserHeaderSelect, onNavigateDate, selectedDate, strings, today = new Date(), yearPickerHidden = false } = props;
    const [navigatedMonthRef, calendarYearRef, focusOnNextUpdate] = useFocusLogic({
        componentRef
    });
    const [isYearPickerVisible, setIsYearPickerVisible] = React.useState(false);
    const animateBackwards = useAnimateBackwards({
        navigatedDate
    });
    const selectMonthCallback = (newMonth)=>{
        return ()=>onSelectMonth(newMonth);
    };
    const onSelectNextYear = ()=>{
        onNavigateDate(addYears(navigatedDate, 1), false);
    };
    const onSelectPrevYear = ()=>{
        onNavigateDate(addYears(navigatedDate, -1), false);
    };
    const onSelectMonth = (newMonth)=>{
        // If header is clickable the calendars are overlayed, switch back to day picker when month is clicked
        onUserHeaderSelect === null || onUserHeaderSelect === void 0 ? void 0 : onUserHeaderSelect();
        onNavigateDate(setMonth(navigatedDate, newMonth), true);
    };
    const onHeaderSelect = ()=>{
        if (!yearPickerHidden) {
            focusOnNextUpdate();
            setIsYearPickerVisible(true);
        } else {
            onUserHeaderSelect === null || onUserHeaderSelect === void 0 ? void 0 : onUserHeaderSelect();
        }
    };
    const onSelectYear = (selectedYear)=>{
        focusOnNextUpdate();
        const navYear = navigatedDate.getFullYear();
        if (navYear !== selectedYear) {
            let newNavigationDate = new Date(navigatedDate.getTime());
            newNavigationDate.setFullYear(selectedYear);
            // for min and max dates, adjust the new navigation date - perhaps this should be
            // checked on the master navigation date handler (i.e. in Calendar)
            if (maxDate && newNavigationDate > maxDate) {
                newNavigationDate = setMonth(newNavigationDate, maxDate.getMonth());
            } else if (minDate && newNavigationDate < minDate) {
                newNavigationDate = setMonth(newNavigationDate, minDate.getMonth());
            }
            onNavigateDate(newNavigationDate, true);
        }
        setIsYearPickerVisible(false);
    };
    const onYearPickerHeaderSelect = (focus)=>{
        focusOnNextUpdate();
        setIsYearPickerVisible(false);
    };
    const dateFormatter = dateTimeFormatter;
    // determine if previous/next years are in bounds
    const isPrevYearInBounds = minDate ? compareDatePart(minDate, getYearStart(navigatedDate)) < 0 : true;
    const isNextYearInBounds = maxDate ? compareDatePart(getYearEnd(navigatedDate), maxDate) < 0 : true;
    const classNames = useCalendarMonthStyles_unstable({
        className,
        hasHeaderClickCallback: !!onUserHeaderSelect || !yearPickerHidden,
        highlightCurrent: highlightCurrentMonth,
        highlightSelected: highlightSelectedMonth,
        animateBackwards,
        animationDirection
    });
    const arrowNavigationAttributes = useArrowNavigationGroup({
        axis: 'grid'
    });
    if (isYearPickerVisible) {
        const [onRenderYear, yearStrings] = getYearStrings({
            dateTimeFormatter,
            navigatedDate,
            strings
        });
        // use navigated date for the year picker
        return /*#__PURE__*/ React.createElement(CalendarYear, {
            key: 'calendarYear',
            minYear: minDate ? minDate.getFullYear() : undefined,
            maxYear: maxDate ? maxDate.getFullYear() : undefined,
            // eslint-disable-next-line react/jsx-no-bind
            onSelectYear: onSelectYear,
            // eslint-disable-next-line react/jsx-no-bind
            onHeaderSelect: onYearPickerHeaderSelect,
            selectedYear: selectedDate ? selectedDate.getFullYear() : navigatedDate ? navigatedDate.getFullYear() : undefined,
            navigatedYear: navigatedDate.getFullYear(),
            navigationIcons: navigationIcons,
            onRenderYear: onRenderYear,
            strings: yearStrings,
            componentRef: calendarYearRef,
            highlightCurrentYear: highlightCurrentMonth,
            highlightSelectedYear: highlightSelectedMonth,
            animationDirection: animationDirection
        });
    }
    const rowIndexes = [];
    for(let i = 0; i < strings.shortMonths.length / MONTHS_PER_ROW; i++){
        rowIndexes.push(i);
    }
    const yearString = dateFormatter.formatYear(navigatedDate);
    const headerAriaLabel = strings.monthPickerHeaderAriaLabel ? strings.monthPickerHeaderAriaLabel.replace('{0}', yearString) : yearString;
    return /*#__PURE__*/ React.createElement("div", {
        className: classNames.root
    }, /*#__PURE__*/ React.createElement("div", {
        className: classNames.headerContainer
    }, /*#__PURE__*/ React.createElement("button", {
        className: classNames.currentItemButton,
        onClick: onHeaderSelect,
        onKeyDown: onButtonKeyDown(onHeaderSelect),
        "aria-label": headerAriaLabel,
        tabIndex: !!onUserHeaderSelect || !yearPickerHidden ? 0 : -1,
        type: "button"
    }, /*#__PURE__*/ React.createElement("span", {
        "aria-live": "polite",
        "aria-atomic": "true"
    }, yearString)), /*#__PURE__*/ React.createElement("div", {
        className: classNames.navigationButtonsContainer
    }, /*#__PURE__*/ React.createElement("button", {
        className: mergeClasses(classNames.navigationButton, !isPrevYearInBounds && classNames.disabled),
        "aria-disabled": !isPrevYearInBounds,
        tabIndex: isPrevYearInBounds ? undefined : allFocusable ? 0 : -1,
        onClick: isPrevYearInBounds ? onSelectPrevYear : undefined,
        onKeyDown: isPrevYearInBounds ? onButtonKeyDown(onSelectPrevYear) : undefined,
        title: strings.prevYearAriaLabel ? strings.prevYearAriaLabel + ' ' + dateFormatter.formatYear(addYears(navigatedDate, -1)) : undefined,
        type: "button"
    }, navigationIcons.upNavigation), /*#__PURE__*/ React.createElement("button", {
        className: mergeClasses(classNames.navigationButton, !isNextYearInBounds && classNames.disabled),
        "aria-disabled": !isNextYearInBounds,
        tabIndex: isNextYearInBounds ? undefined : allFocusable ? 0 : -1,
        onClick: isNextYearInBounds ? onSelectNextYear : undefined,
        onKeyDown: isNextYearInBounds ? onButtonKeyDown(onSelectNextYear) : undefined,
        title: strings.nextYearAriaLabel ? strings.nextYearAriaLabel + ' ' + dateFormatter.formatYear(addYears(navigatedDate, 1)) : undefined,
        type: "button"
    }, navigationIcons.downNavigation))), /*#__PURE__*/ React.createElement("div", {
        ...arrowNavigationAttributes,
        className: classNames.gridContainer,
        role: "grid",
        "aria-label": yearString
    }, rowIndexes.map((rowNum)=>{
        const monthsForRow = strings.shortMonths.slice(rowNum * MONTHS_PER_ROW, (rowNum + 1) * MONTHS_PER_ROW);
        return /*#__PURE__*/ React.createElement("div", {
            key: 'monthRow_' + rowNum + navigatedDate.getFullYear(),
            role: "row",
            className: classNames.buttonRow
        }, monthsForRow.map((month, index)=>{
            const monthIndex = rowNum * MONTHS_PER_ROW + index;
            const indexedMonth = setMonth(navigatedDate, monthIndex);
            const isNavigatedMonth = navigatedDate.getMonth() === monthIndex;
            const isSelectedMonth = selectedDate.getMonth() === monthIndex;
            const isSelectedYear = selectedDate.getFullYear() === navigatedDate.getFullYear();
            const isInBounds = (minDate ? compareDatePart(minDate, getMonthEnd(indexedMonth)) < 1 : true) && (maxDate ? compareDatePart(getMonthStart(indexedMonth), maxDate) < 1 : true);
            return /*#__PURE__*/ React.createElement("button", {
                ref: isNavigatedMonth ? navigatedMonthRef : undefined,
                role: 'gridcell',
                className: mergeClasses(classNames.itemButton, highlightCurrentMonth && isCurrentMonth(monthIndex, navigatedDate.getFullYear(), today) && classNames.current, highlightSelectedMonth && isSelectedMonth && isSelectedYear && classNames.selected, !isInBounds && classNames.disabled),
                disabled: !allFocusable && !isInBounds,
                key: monthIndex,
                onClick: isInBounds ? selectMonthCallback(monthIndex) : undefined,
                onKeyDown: isInBounds ? onButtonKeyDown(selectMonthCallback(monthIndex)) : undefined,
                "aria-label": dateFormatter.formatMonth(indexedMonth, strings),
                "aria-selected": isNavigatedMonth,
                tabIndex: isInBounds ? 0 : -1,
                type: "button"
            }, month);
        }));
    })));
};
CalendarMonth.displayName = 'CalendarMonth';
function getYearStrings({ dateTimeFormatter, navigatedDate, strings }) {
    const yearToString = (year)=>{
        if (dateTimeFormatter) {
            // create a date based on the current nav date
            const yearFormattingDate = new Date(navigatedDate.getTime());
            yearFormattingDate.setFullYear(year);
            return dateTimeFormatter.formatYear(yearFormattingDate);
        }
        return String(year);
    };
    const yearRangeToString = (yearRange)=>{
        return `${yearToString(yearRange.fromYear)} - ${yearToString(yearRange.toYear)}`;
    };
    const yearRangeToNextDecadeLabel = (yearRange)=>{
        return strings.nextYearRangeAriaLabel ? `${strings.nextYearRangeAriaLabel} ${yearRangeToString(yearRange)}` : '';
    };
    const yearRangeToPrevDecadeLabel = (yearRange)=>{
        return strings.prevYearRangeAriaLabel ? `${strings.prevYearRangeAriaLabel} ${yearRangeToString(yearRange)}` : '';
    };
    return [
        yearToString,
        {
            rangeAriaLabel: yearRangeToString,
            prevRangeAriaLabel: yearRangeToPrevDecadeLabel,
            nextRangeAriaLabel: yearRangeToNextDecadeLabel,
            headerAriaLabelFormatString: strings.yearPickerHeaderAriaLabel
        }
    ];
}
function isCurrentMonth(month, year, today) {
    return today.getFullYear() === year && today.getMonth() === month;
}
function onButtonKeyDown(callback) {
    return (ev)=>{
        switch(ev.key){
            case Enter:
                callback();
                break;
        }
    };
}
