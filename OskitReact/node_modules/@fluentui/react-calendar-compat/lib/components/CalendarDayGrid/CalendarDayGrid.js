import * as React from 'react';
import { useArrowNavigationGroup } from '@fluentui/react-tabster';
import { useId } from '@fluentui/react-utilities';
import { getBoundedDateRange, getDateRangeArray, isRestrictedDate, DateRangeType } from '../../utils';
import { useCalendarDayGridStyles_unstable } from './useCalendarDayGridStyles.styles';
import { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';
import { CalendarGridRow } from './CalendarGridRow';
import { useWeeks } from './useWeeks';
import { useWeekCornerStyles } from './useWeekCornerStyles.styles';
import { mergeClasses } from '@griffel/react';
function useDayRefs() {
    const daysRef = React.useRef({});
    const getSetRefCallback = (dayKey)=>(element)=>{
            if (element === null) {
                delete daysRef.current[dayKey];
            } else {
                daysRef.current[dayKey] = element;
            }
        };
    return [
        daysRef,
        getSetRefCallback
    ];
}
function useAnimateBackwards(weeks) {
    const previousNavigatedDateRef = React.useRef();
    React.useEffect(()=>{
        previousNavigatedDateRef.current = weeks[0][0].originalDate;
    });
    const previousNavigatedDate = previousNavigatedDateRef.current;
    if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {
        return undefined;
    } else if (previousNavigatedDate <= weeks[0][0].originalDate) {
        return false;
    } else {
        return true;
    }
}
export const CalendarDayGrid = (props)=>{
    const navigatedDayRef = React.useRef(null);
    const activeDescendantId = useId();
    const onSelectDate = (selectedDate)=>{
        var _props_onSelectDate, _props_onNavigateDate;
        const { firstDayOfWeek, minDate, maxDate, workWeekDays, daysToSelectInDayView, restrictedDates } = props;
        const restrictedDatesOptions = {
            minDate,
            maxDate,
            restrictedDates
        };
        let dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);
        dateRange = getBoundedDateRange(dateRange, minDate, maxDate);
        dateRange = dateRange.filter((d)=>{
            return !isRestrictedDate(d, restrictedDatesOptions);
        });
        (_props_onSelectDate = props.onSelectDate) === null || _props_onSelectDate === void 0 ? void 0 : _props_onSelectDate.call(props, selectedDate, dateRange);
        (_props_onNavigateDate = props.onNavigateDate) === null || _props_onNavigateDate === void 0 ? void 0 : _props_onNavigateDate.call(props, selectedDate, true);
    };
    const [daysRef, getSetRefCallback] = useDayRefs();
    const weeks = useWeeks(props, onSelectDate, getSetRefCallback);
    const animateBackwards = useAnimateBackwards(weeks);
    const [getWeekCornerStyles, calculateRoundedStyles] = useWeekCornerStyles(props);
    React.useImperativeHandle(props.componentRef, ()=>({
            focus () {
                var _navigatedDayRef_current_focus, _navigatedDayRef_current;
                (_navigatedDayRef_current = navigatedDayRef.current) === null || _navigatedDayRef_current === void 0 ? void 0 : (_navigatedDayRef_current_focus = _navigatedDayRef_current.focus) === null || _navigatedDayRef_current_focus === void 0 ? void 0 : _navigatedDayRef_current_focus.call(_navigatedDayRef_current);
            }
        }), []);
    /**
   *
   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support
   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks
   * to set classnames on all relevant child refs to apply the styling
   *
   */ const getDayInfosInRangeOfDay = (dayToCompare)=>{
        // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state
        const dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);
        // gets all the dates for the given date range type that are in the same date range as the given day
        const dateRange = getDateRangeArray(dayToCompare.originalDate, dateRangeHoverType, props.firstDayOfWeek, props.workWeekDays, props.daysToSelectInDayView).map((date)=>date.getTime());
        // gets all the day refs for the given dates
        const dayInfosInRange = weeks.reduce((accumulatedValue, currentWeek)=>{
            return accumulatedValue.concat(currentWeek.filter((weekDay)=>dateRange.indexOf(weekDay.originalDate.getTime()) !== -1));
        }, []);
        return dayInfosInRange;
    };
    const getRefsFromDayInfos = (dayInfosInRange)=>{
        let dayRefs = [];
        dayRefs = dayInfosInRange.map((dayInfo)=>daysRef.current[dayInfo.key]);
        return dayRefs;
    };
    const { gridLabel, dateRangeType, showWeekNumbers, labelledBy, lightenDaysOutsideNavigatedMonth, animationDirection } = props;
    const classNames = useCalendarDayGridStyles_unstable({
        animateBackwards,
        animationDirection,
        dateRangeType,
        lightenDaysOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,
        showWeekNumbers
    });
    // When the month is highlighted get the corner dates so that styles can be added to them
    const weekCorners = getWeekCornerStyles(weeks);
    const partialWeekProps = {
        weeks,
        navigatedDayRef,
        calculateRoundedStyles,
        activeDescendantId,
        classNames,
        weekCorners,
        getDayInfosInRangeOfDay,
        getRefsFromDayInfos
    };
    const arrowNavigationAttributes = useArrowNavigationGroup({
        axis: 'grid'
    });
    return /*#__PURE__*/ React.createElement("table", {
        className: mergeClasses(classNames.table, props.className),
        "aria-multiselectable": "false",
        "aria-label": gridLabel,
        "aria-labelledby": labelledBy,
        "aria-activedescendant": activeDescendantId,
        role: "grid",
        ...arrowNavigationAttributes
    }, /*#__PURE__*/ React.createElement("tbody", null, /*#__PURE__*/ React.createElement(CalendarMonthHeaderRow, {
        ...props,
        classNames: classNames,
        weeks: weeks
    }), /*#__PURE__*/ React.createElement(CalendarGridRow, {
        ...props,
        ...partialWeekProps,
        week: weeks[0],
        weekIndex: -1,
        rowClassName: classNames.firstTransitionWeek,
        "aria-role": "presentation",
        ariaHidden: true
    }), weeks.slice(1, weeks.length - 1).map((week, weekIndex)=>/*#__PURE__*/ React.createElement(CalendarGridRow, {
            ...props,
            ...partialWeekProps,
            key: weekIndex,
            week: week,
            weekIndex: weekIndex,
            rowClassName: classNames.weekRow
        })), /*#__PURE__*/ React.createElement(CalendarGridRow, {
        ...props,
        ...partialWeekProps,
        week: weeks[weeks.length - 1],
        weekIndex: -2,
        rowClassName: classNames.lastTransitionWeek,
        "aria-role": "presentation",
        ariaHidden: true
    })));
};
CalendarDayGrid.displayName = 'CalendarDayGrid';
/**
 * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous
 * work weeks, we'll just show week view instead.
 */ function getDateRangeTypeToUse(dateRangeType, workWeekDays) {
    if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {
        const sortedWWDays = workWeekDays.slice().sort();
        let isContiguous = true;
        for(let i = 1; i < sortedWWDays.length; i++){
            if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {
                isContiguous = false;
                break;
            }
        }
        if (!isContiguous || workWeekDays.length === 0) {
            return DateRangeType.Week;
        }
    }
    return dateRangeType;
}
