import * as React from 'react';
import { ArrowDown, ArrowLeft, ArrowRight, ArrowUp, Enter } from '@fluentui/keyboard-keys';
import { getRTLSafeKey } from '@fluentui/react-utilities';
import { useFluent_unstable } from '@fluentui/react-shared-contexts';
import { mergeClasses } from '@griffel/react';
import { addDays, addWeeks, compareDates, findAvailableDate, DateRangeType } from '../../utils';
import { weekCornersClassNames } from './useWeekCornerStyles.styles';
import { extraCalendarDayGridClassNames } from './useCalendarDayGridStyles.styles';
/**
 * @internal
 */ export const CalendarGridDayCell = (props)=>{
    'use no memo';
    const { navigatedDate, dateTimeFormatter, allFocusable, strings, activeDescendantId, navigatedDayRef, calculateRoundedStyles, weeks, classNames, day, dayIndex, weekIndex, weekCorners, ariaHidden, customDayCellRef, dateRangeType, daysToSelectInDayView, onSelectDate, restrictedDates, minDate, maxDate, onNavigateDate, getDayInfosInRangeOfDay, getRefsFromDayInfos } = props;
    var _weekCorners_;
    const cornerStyle = (_weekCorners_ = weekCorners === null || weekCorners === void 0 ? void 0 : weekCorners[weekIndex + '_' + dayIndex]) !== null && _weekCorners_ !== void 0 ? _weekCorners_ : '';
    const isNavigatedDate = compareDates(navigatedDate, day.originalDate);
    const { dir } = useFluent_unstable();
    const navigateMonthEdge = (ev, date)=>{
        let targetDate = undefined;
        let direction = 1; // by default search forward
        if (ev.key === ArrowUp) {
            targetDate = addWeeks(date, -1);
            direction = -1;
        } else if (ev.key === ArrowDown) {
            targetDate = addWeeks(date, 1);
        } else if (ev.key === getRTLSafeKey(ArrowLeft, dir)) {
            targetDate = addDays(date, -1);
            direction = -1;
        } else if (ev.key === getRTLSafeKey(ArrowRight, dir)) {
            targetDate = addDays(date, 1);
        }
        if (!targetDate) {
            // if we couldn't find a target date at all, do nothing
            return;
        }
        const findAvailableDateOptions = {
            initialDate: date,
            targetDate,
            direction,
            restrictedDates,
            minDate,
            maxDate
        };
        // target date is restricted, search in whatever direction until finding the next possible date,
        // stopping at boundaries
        let nextDate = findAvailableDate(findAvailableDateOptions);
        if (!nextDate) {
            // if no dates available in initial direction, try going backwards
            findAvailableDateOptions.direction = -direction;
            nextDate = findAvailableDate(findAvailableDateOptions);
        }
        // if the nextDate is still inside the same focusZone area, let the focusZone handle setting the focus so we
        // don't jump the view unnecessarily
        const isInCurrentView = weeks && nextDate && weeks.slice(1, weeks.length - 1).some((week)=>{
            return week.some((dayToCompare)=>{
                return compareDates(dayToCompare.originalDate, nextDate);
            });
        });
        if (isInCurrentView) {
            return;
        }
        // else, fire navigation on the date to change the view to show it
        if (nextDate) {
            onNavigateDate(nextDate, true);
            ev.preventDefault();
        }
    };
    const onMouseOverDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef, index)=>{
            if (dayRef) {
                dayRef.classList.add(extraCalendarDayGridClassNames.hoverStyle);
                if (!dayInfos[index].isSelected && dateRangeType === DateRangeType.Day && daysToSelectInDayView && daysToSelectInDayView > 1) {
                    // remove the static classes first to overwrite them
                    dayRef.classList.remove(weekCornersClassNames.bottomLeftCornerDate, weekCornersClassNames.bottomRightCornerDate, weekCornersClassNames.topLeftCornerDate, weekCornersClassNames.topRightCornerDate);
                    const classNamesToAdd = calculateRoundedStyles(false, false, index > 0, index < dayRefs.length - 1).trim();
                    if (classNamesToAdd) {
                        dayRef.classList.add(...classNamesToAdd.trim().split(' '));
                    }
                }
            }
        });
    };
    const onMouseDownDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef)=>{
            if (dayRef) {
                dayRef.classList.add(extraCalendarDayGridClassNames.pressedStyle);
            }
        });
    };
    const onMouseUpDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef)=>{
            if (dayRef) {
                dayRef.classList.remove(extraCalendarDayGridClassNames.pressedStyle);
            }
        });
    };
    const onMouseOutDay = (ev)=>{
        const dayInfos = getDayInfosInRangeOfDay(day);
        const dayRefs = getRefsFromDayInfos(dayInfos);
        dayRefs.forEach((dayRef, index)=>{
            if (dayRef) {
                dayRef.classList.remove(extraCalendarDayGridClassNames.hoverStyle);
                dayRef.classList.remove(extraCalendarDayGridClassNames.pressedStyle);
                if (!dayInfos[index].isSelected && dateRangeType === DateRangeType.Day && daysToSelectInDayView && daysToSelectInDayView > 1) {
                    const classNamesToAdd = calculateRoundedStyles(false, false, index > 0, index < dayRefs.length - 1).trim();
                    if (classNamesToAdd) {
                        dayRef.classList.remove(...classNamesToAdd.trim().split(' '));
                    }
                }
            }
        });
    };
    const onDayKeyDown = (ev)=>{
        if (ev.key === Enter) {
            onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(day.originalDate);
        } else {
            navigateMonthEdge(ev, day.originalDate);
        }
    };
    let ariaLabel = day.originalDate.getDate() + ', ' + strings.months[day.originalDate.getMonth()] + ', ' + day.originalDate.getFullYear();
    if (day.isMarked) {
        ariaLabel = ariaLabel + ', ' + strings.dayMarkedAriaLabel;
    }
    const isFocusable = !ariaHidden && (allFocusable || (day.isInBounds ? true : undefined));
    return /*#__PURE__*/ React.createElement("td", {
        className: mergeClasses(classNames.dayCell, weekCorners && cornerStyle, day.isSelected && !day.isSingleSelected && classNames.daySelected, day.isSingleSelected && classNames.daySingleSelected, !day.isInBounds && classNames.dayOutsideBounds, !day.isInMonth && classNames.dayOutsideNavigatedMonth),
        ref: (element)=>{
            customDayCellRef === null || customDayCellRef === void 0 ? void 0 : customDayCellRef(element, day.originalDate, classNames);
            day.setRef(element);
            isNavigatedDate && (navigatedDayRef.current = element);
        },
        "aria-disabled": !ariaHidden && !day.isInBounds,
        onClick: day.isInBounds && !ariaHidden ? day.onSelected : undefined,
        onMouseOver: !ariaHidden ? onMouseOverDay : undefined,
        onMouseDown: !ariaHidden ? onMouseDownDay : undefined,
        onMouseUp: !ariaHidden ? onMouseUpDay : undefined,
        onMouseOut: !ariaHidden ? onMouseOutDay : undefined,
        onKeyDown: !ariaHidden ? onDayKeyDown : undefined,
        role: "gridcell",
        tabIndex: isNavigatedDate || isFocusable ? 0 : undefined,
        "aria-current": day.isToday ? 'date' : undefined,
        "aria-selected": day.isInBounds ? day.isSelected : undefined
    }, /*#__PURE__*/ React.createElement("button", {
        key: day.key + 'button',
        className: mergeClasses(classNames.dayButton, day.isToday && classNames.dayIsToday),
        "aria-label": ariaLabel,
        id: isNavigatedDate ? activeDescendantId : undefined,
        disabled: !ariaHidden && !day.isInBounds,
        type: "button",
        tabIndex: -1
    }, /*#__PURE__*/ React.createElement("span", {
        className: day.isToday ? mergeClasses(classNames.dayTodayMarker) : undefined
    }, dateTimeFormatter.formatDay(day.originalDate)), day.isMarked && /*#__PURE__*/ React.createElement("div", {
        "aria-hidden": "true",
        className: classNames.dayMarker
    })));
};
